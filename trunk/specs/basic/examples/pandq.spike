specification : pandq

sorts : nat  bool;
$ 
$Fixpoint model_nat (v: nat): term :=
$match v with
$| O => (Term id_0 nil)
$| (S x) => let r := model_nat x in   (Term id_S (r::nil))
$ end.
$
$Fixpoint model_bool (v: bool): term :=
$match v with
$|true => (Term id_true nil)
$|false => (Term id_false nil)
$end.

constructors :

0    :          -> nat;
S_ : nat -> nat;
true : bool;
false : bool;
 

defined functions:

P_ : nat -> bool;
Q__ : nat nat-> bool;
 
axioms:

P(0) = true;
P(x) = true, Q(x,S(x)) = true => P(S(x)) = true;
P(x) = false => P(S(x)) = false;
Q(x, S(x)) = false => P(S(x)) = false;

Q(x,0) = true;
Q(x, y) = true, P(x) = true => Q(x, S(y)) = true;
Q(x, y) = false => Q(x, S(y)) = false;
P(x) = false => Q(x, S(y)) = false;


  
greater:
P: S 0 true false; 
 
equiv:
P Q;

properties:

system_is_sufficiently_complete ;
system_is_strongly_sufficiently_complete ;
system_is_ground_convergent ;


Strategy:

% instances of Delete
tautology_rule                   = delete(id, [tautology]);
subsumption_rule                 = delete(id, [subsumption (L|C)]);
negative_clash_rule              = Delete(id, [negative_clash]);

% instances of Simplify
decomposition_rule = simplify(id, [negative_decomposition]);
rewriting_rule = simplify(id,[rewriting(rewrite, L|R|C, *)]);
total_case_rewriting_rule = simplify(id, [total_case_rewriting (simplify_strat, r, *)]);


% instances of AddPremise
total_case_rewriting_add_premise_rule = add_premise(total_case_rewriting(simplify_strat, r, *),[id]);
inst_var_rule = add_premise(generate,[id]);


stra = repeat (try (
                    tautology_rule,
                    negative_clash_rule,
                    subsumption_rule,
                    decomposition_rule,
                    
rewriting_rule,      
                    print_goals,
total_case_rewriting_add_premise_rule 

));

fullind = (repeat(stra, inst_var_rule), print_goals_with_history);

start_with: fullind

conjectures: 
P(x) = true;
Q(x,y) = true;
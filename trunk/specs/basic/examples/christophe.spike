specification : aoto % conjectures taken from Aoto's RTA'2006 paper.

sorts : nat list bool;

constructors :

True : -> bool;
False : -> bool;
0    :          -> nat;
S_ : nat -> nat;
Nil : -> list;
Cons__ : nat list -> list; % bags are lists here

defined functions:

_<=_: nat nat -> bool;
_-_ : nat nat -> nat;
boundContent___: list nat nat -> list; 
union__: list list -> list; % is append on lists
nth__: list nat -> nat;

axioms:

0 - x = 0;
S(x) - 0 = S(x);
S(x) - S(y) = x - y;

0 <= x = True;
S(x) <= 0 = False;
S(x) <= S(y) = x <= y;

union(Nil, x) = x;
union(Cons(x,l), l1) = Cons(x, union(l,l1));

nth(Nil, i) = 0;
nth(Cons(x,l), 0) = x;
nth(Cons(x,l), S(y)) = nth(l,y); 

i <= j = True => boundContent(l, i, j) = union(Cons(nth(l,i), Nil), boundContent(l, S(i), j) ); 
i <= j = False => boundContent(l, i, j)  = Nil;

 

% greater:
% boundContent:  union nth - <= S 0 Cons Nil True False;

properties:

system_is_sufficiently_complete ;
system_is_strongly_sufficiently_complete ;
system_is_ground_convergent ;


Strategy:
       tautology_rule                   = Delete(id, [tautology]);
       negative_clash_rule              = Delete(id, [negative_clash]);
       subsumption_rule                 = Delete(id, [subsumption (L|C)]);
       eliminate_redundant_literal_rule = simplify(id, [eliminate_redundant_literal]);
       eliminate_trivial_literal_rule   = simplify(id, [eliminate_trivial_literal]);
       positive_clash_rule              = simplify(id, [positive_clash]);
       congruence_closure_rule          = simplify(id, [congruence_closure]);
       negative_decomposition_rule      = simplify(id, [negative_decomposition]);
       auto_simplification_rule         = simplify(id, [auto_simplification]);
       conditional_rewriting_rule2      = simplify(id, [conditional_rewriting(rewrite, R, *)]);
       total_case_rewriting_rule        = simplify(id, [total_case_rewriting (simplify_strat, r, *)]);
       induction1 = add_premise(generate,[id]);

       stra = repeat (try (
                   tautology_rule,
                   negative_clash_rule,
                   eliminate_redundant_literal_rule,
                   eliminate_trivial_literal_rule,
                   positive_clash_rule,
                   congruence_closure_rule,
                   negative_decomposition_rule,
                   auto_simplification_rule,
                   conditional_rewriting_rule2,
                   subsumption_rule,
                   print_goals,
                   total_case_rewriting_rule
       ));

       strategie = (induction1, stra, print_goals_with_history);
       rewrite   = (stra, print_goals_with_history);
       fullind   = (repeat(stra, induction1), print_goals_with_history);

start_with: fullind
 

Conjectures:

i <= S(j) = True => boundContent(l, i, S(j)) = union(boundContent(l, i, j), Cons(nth(l,S(j)), Nil)); 
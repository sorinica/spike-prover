<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>unification.free_unif</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library unification.free_unif</h1>

<div class="code">

<br/>
<span class="id" type="keyword">Add</span> <span class="id" type="var">LoadPath</span> "basis".<br/>
<span class="id" type="keyword">Add</span> <span class="id" type="var">LoadPath</span> "list_extensions".<br/>
<span class="id" type="keyword">Add</span> <span class="id" type="var">LoadPath</span> "term_algebra".<br/>
<span class="id" type="keyword">Add</span> <span class="id" type="var">LoadPath</span> "term_orderings".<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Arith</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Wf_nat</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Wellfounded</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Max</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Min</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">List</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Multiset</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">closure</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">decidable_set</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">ordered_set</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">more_list</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">list_permut</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">list_set</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">list_sort</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">dickson</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Relations</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">term_spec</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">term</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">Dummy_bool</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">b</span>, <span class="id" type="var">negb</span> <span class="id" type="var">b</span> = <span class="id" type="var">true</span> &lt;-&gt; <span class="id" type="var">b</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> [ | ]; <span class="id" type="tactic">intuition</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">Make</span> (<span class="id" type="var">T1</span>: <span class="id" type="var">Term</span>) <br/>
(<span class="id" type="var">OF1</span> : <span class="id" type="var">ordered_set.S</span> <span class="id" type="keyword">with</span> <span class="id" type="keyword">Definition</span> <span class="id" type="var">A</span> := <span class="id" type="var">T1.symbol</span>) <br/>
(<span class="id" type="var">OX1</span> : <span class="id" type="var">ordered_set.S</span> <span class="id" type="keyword">with</span> <span class="id" type="keyword">Definition</span> <span class="id" type="var">A</span> := <span class="id" type="var">T1.variable</span>).<br/>

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">T</span> := <span class="id" type="var">T1</span>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">T1</span>.<br/>

<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">X</span>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">exc</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Set</span>) : <span class="id" type="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">Normal</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="var">exc</span> <span class="id" type="var">A</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="var">exc</span> <span class="id" type="var">A</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> : <span class="id" type="var">exc</span> <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">bind</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Set</span>) (<span class="id" type="var">f</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="var">exc</span> <span class="id" type="var">A</span>)  (<span class="id" type="var">x</span> : <span class="id" type="var">exc</span> <span class="id" type="var">A</span>) : (<span class="id" type="var">exc</span> <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">x</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">a</span> =&gt; <span class="id" type="var">f</span> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> <span class="id" type="var">a</span> =&gt; <span class="id" type="var">Not_appliable</span> <span class="id" type="var">A</span> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> =&gt; @<span class="id" type="var">No_solution</span> <span class="id" type="var">A</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Record</span> <span class="id" type="var">unification_problem</span> : <span class="id" type="keyword">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">mk_pb</span> <br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">solved_part</span> : <span class="id" type="var">substitution</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">unsolved_part</span> : <span class="id" type="var">list</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)<br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">combine</span> <span class="id" type="var">A</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> (<span class="id" type="var">A</span> * <span class="id" type="var">A</span>))  (<span class="id" type="var">l1</span> <span class="id" type="var">l2</span> : <span class="id" type="var">list</span> <span class="id" type="var">A</span>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">l1</span>} : <span class="id" type="var">list</span> (<span class="id" type="var">A</span> * <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l1</span>, <span class="id" type="var">l2</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span>, <span class="id" type="var">_</span> =&gt; <span class="id" type="var">l</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">l</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">a1</span> :: <span class="id" type="var">l1</span>), (<span class="id" type="var">a2</span> :: <span class="id" type="var">l2</span>) =&gt; <span class="id" type="var">combine</span> <span class="id" type="var">_</span> ((<span class="id" type="var">a1</span>,a2) :: <span class="id" type="var">l</span>) <span class="id" type="var">l1</span> <span class="id" type="var">l2</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt_ge_dec</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>, {<span class="id" type="var">x</span> &lt; <span class="id" type="var">y</span>} + {<span class="id" type="var">x</span> &gt;= <span class="id" type="var">y</span>} :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> =&gt; <span class="id" type="var">Sumbool.sumbool_not</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">le_lt_dec</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">decomposition_step</span> (<span class="id" type="var">pb</span> : <span class="id" type="var">unification_problem</span>) : <span class="id" type="var">exc</span> <span class="id" type="var">unification_problem</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; @<span class="id" type="var">Not_appliable</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span><br/>
&nbsp;&nbsp;&nbsp;| (<span class="id" type="var">s</span>,t) :: <span class="id" type="var">l</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">T.eq_bool</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">s</span>, <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Var</span> <span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">x_maps_to_y</span> := (<span class="id" type="var">x</span>, <span class="id" type="var">t</span>) :: <span class="id" type="var">nil</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">solved_part'</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">map_subst</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> <span class="id" type="var">v_sigma</span> =&gt; <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,t) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">l'</span> := <span class="id" type="var">map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">uv</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">uv</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" type="var">u</span>, <span class="id" type="var">v</span>) =&gt; (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,t) :: <span class="id" type="var">nil</span>) <span class="id" type="var">u</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,t) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>) <span class="id" type="var">l</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">solved_part'</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> =&gt; <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">t</span>) :: <span class="id" type="var">solved_part'</span>) ((<span class="id" type="var">t</span>, <span class="id" type="var">x_val</span>) :: <span class="id" type="var">l'</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">t</span>) :: <span class="id" type="var">solved_part'</span>) <span class="id" type="var">l'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Var</span> <span class="id" type="var">x</span>, (<span class="id" type="var">Term</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="keyword">as</span> <span class="id" type="var">u</span>) =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>,u) :: <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>)) <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> <span class="id" type="var">u</span>) (<span class="id" type="var">T.size</span> <span class="id" type="var">x_val</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span>  <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>,u) :: <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>)) ((<span class="id" type="var">x_val</span>,u) :: <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span>  <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) ((<span class="id" type="var">x_val</span>,u) :: <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" type="var">Term</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="keyword">as</span> <span class="id" type="var">u</span>), <span class="id" type="var">Var</span> <span class="id" type="var">x</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>,u) :: <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>)) <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> <span class="id" type="var">u</span>)  (<span class="id" type="var">T.size</span> <span class="id" type="var">x_val</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>,u) :: <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>)) ((<span class="id" type="var">x_val</span>,u) :: <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) ((<span class="id" type="var">x_val</span>,u) :: <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">F.Symb.eq_bool</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">beq_nat</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">true</span> =&gt; <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) (<span class="id" type="var">combine</span> <span class="id" type="var">_</span> <span class="id" type="var">l</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">false</span> =&gt; @<span class="id" type="var">No_solution</span> <span class="id" type="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> @<span class="id" type="var">No_solution</span> <span class="id" type="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb</span> <span class="id" type="var">theta</span> :=<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>, <span class="id" type="var">In</span> (<span class="id" type="var">s</span>,t) <span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>) -&gt; <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">s</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;/\<br/>
&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, <span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> =&gt; <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">x_val</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">DecVar</span> := <span class="id" type="var">decidable_set.Convert</span> (<span class="id" type="var">X</span>).<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">VSet</span> &lt;: <span class="id" type="var">list_set.S</span> <span class="id" type="keyword">with</span> <span class="id" type="keyword">Definition</span> <span class="id" type="var">EDS.A</span> := <span class="id" type="var">variable</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">list_set.Make</span> (<span class="id" type="var">DecVar</span>).<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">unfold_types</span> := <br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.LP.EDS.A</span>, <span class="id" type="var">DecVar.A</span>, <span class="id" type="var">variable</span> <span class="id" type="keyword">in</span> *.<br/>

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">destruct_set</span> <span class="id" type="var">S</span> <span class="id" type="var">S1</span> <span class="id" type="var">S2</span> :=  <br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.union_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">S</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">S1</span> | <span class="id" type="var">S2</span>]; <span class="id" type="tactic">clear</span> <span class="id" type="var">S</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">set_of_variables</span> (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) : <span class="id" type="var">VSet.t</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Var</span> <span class="id" type="var">v</span> =&gt; <span class="id" type="var">VSet.singleton</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Term</span> <span class="id" type="var">_</span> <span class="id" type="var">l</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">set_of_variables_list</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">fix</span> <span class="id" type="var">set_of_variables_list</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">term</span>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">l</span>} : <span class="id" type="var">VSet.t</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">VSet.empty</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">t</span> :: <span class="id" type="var">lt</span> =&gt; <span class="id" type="var">VSet.union</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>) (<span class="id" type="var">set_of_variables_list</span> <span class="id" type="var">lt</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">set_of_variables_list</span> <span class="id" type="var">l</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">set_of_variables_list</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">term</span>) : <span class="id" type="var">VSet.t</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">VSet.empty</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">t</span> :: <span class="id" type="var">lt</span> =&gt; <span class="id" type="var">VSet.union</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>) (<span class="id" type="var">set_of_variables_list</span> <span class="id" type="var">lt</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)) : <span class="id" type="var">VSet.t</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">VSet.empty</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">s</span>,t) :: <span class="id" type="var">l</span> =&gt; <span class="id" type="var">VSet.union</span> (<span class="id" type="var">VSet.union</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">s</span>) (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">domain_of_subst</span> (<span class="id" type="var">sigma</span> : <span class="id" type="var">substitution</span>) : <span class="id" type="var">VSet.t</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">VSet.empty</span><br/>
&nbsp;&nbsp;&nbsp;| (<span class="id" type="var">x</span>,_) :: <span class="id" type="var">sigma</span> =&gt; <span class="id" type="var">VSet.add</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">set_of_variables_in_range_of_subst</span> (<span class="id" type="var">sigma</span> : <span class="id" type="var">substitution</span>) : <span class="id" type="var">VSet.t</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">VSet.empty</span><br/>
&nbsp;&nbsp;&nbsp;| (<span class="id" type="var">_</span>,t) :: <span class="id" type="var">sigma</span> =&gt; <span class="id" type="var">VSet.union</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">var_in_domain_of_subst</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">v</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>) &lt;-&gt; (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> &lt;&gt; <span class="id" type="var">None</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">x</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>]; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">IHsigma</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.add_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">v_eq_x</span> | <span class="id" type="var">v_in_dom</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">assumption</span>].<br/>
<span class="id" type="var">absurd</span> (<span class="id" type="var">v</span> = <span class="id" type="var">x</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">v_eq_x</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">v_diff_x</span> <span class="id" type="var">H</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_1</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_2</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">apply_subst_outside_dom</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">t</span>, <span class="id" type="var">VSet.eq_set</span> (<span class="id" type="var">VSet.inter</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>) (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.empty</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> <span class="id" type="var">t</span> = <span class="id" type="var">t</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">x</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> : <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> <span class="id" type="var">VSet.empty</span>).<br/>
<span class="id" type="tactic">rewrite</span> &lt;-  (<span class="id" type="var">H</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.inter_12</span>; <br/>
[ <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_1</span> | <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_x_dom_sig</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_empty</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">H</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.inter_12</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_2</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.inter_1</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_x_dom_sig</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.inter_2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_x_dom_sig</span>).<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">IH</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>;  <span class="id" type="tactic">apply</span> (<span class="id" type="tactic">f_equal</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">l</span> =&gt; <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s</span> <span class="id" type="var">l</span>].<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IH</span> <span class="id" type="var">s</span>); [<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="var">idtac</span> ].<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_dom_sig_l</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_empty</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">H</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.inter_12</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.inter_1</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_dom_sig_l</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.inter_2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_dom_sig_l</span>).<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_dom_sig_s</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_empty</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">H</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.inter_12</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.inter_1</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_dom_sig_s</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.inter_2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_dom_sig_s</span>).<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">occ_var_is_a_subterm_at_pos</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">t</span>, <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>) -&gt; <br/>
&nbsp;&nbsp;<span class="id" type="var">exists</span> <span class="id" type="var">p</span>, <span class="id" type="var">subterm_at_pos</span> <span class="id" type="var">t</span> <span class="id" type="var">p</span> = <span class="id" type="var">Some</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">x_eq_v</span> | <span class="id" type="var">x_in_nil</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="var">exists</span> (@<span class="id" type="var">nil</span> <span class="id" type="var">nat</span>); <br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.LP.EDS.eq_A</span>, <span class="id" type="var">VSet.EDS.eq_A</span> , <span class="id" type="var">DecVar.eq_A</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">IH</span> <span class="id" type="var">x_in_l</span>; <br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="var">exists</span> <span class="id" type="var">s</span>, <span class="id" type="var">exists</span> <span class="id" type="var">i</span>, <span class="id" type="var">In</span> <span class="id" type="var">s</span> <span class="id" type="var">l</span> /\ <span class="id" type="var">nth_error</span> <span class="id" type="var">l</span> <span class="id" type="var">i</span> = <span class="id" type="var">Some</span> <span class="id" type="var">s</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\ <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">s</span>)).<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">t</span> <span class="id" type="var">l</span>]; [<span class="id" type="var">contradiction</span> | <span class="id" type="var">idtac</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_l</span> <span class="id" type="var">x_in_t</span> <span class="id" type="var">x_in_l'</span>.<br/>
<span class="id" type="var">exists</span> <span class="id" type="var">t</span>; <span class="id" type="var">exists</span> 0; <span class="id" type="tactic">split</span>; [<span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">split</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">simpl</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IHl</span> <span class="id" type="var">x_in_l'</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">s</span> [<span class="id" type="var">i</span> [<span class="id" type="var">s_in_l</span> [<span class="id" type="var">s_eq_li</span>  <span class="id" type="var">x_in_s</span>]]]]; <span class="id" type="var">exists</span> <span class="id" type="var">s</span>; <span class="id" type="var">exists</span> (<span class="id" type="var">S</span> <span class="id" type="var">i</span>).<br/>
<span class="id" type="tactic">split</span>; [<span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">split</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">s</span> [<span class="id" type="var">i</span> [<span class="id" type="var">s_in_l</span> [<span class="id" type="var">s_eq_li</span> <span class="id" type="var">x_in_s</span>]]]].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">IH</span> <span class="id" type="var">s</span> <span class="id" type="var">s_in_l</span> <span class="id" type="var">x_in_s</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">p</span> <span class="id" type="var">H</span>].<br/>
<span class="id" type="var">exists</span> (<span class="id" type="var">i</span> :: <span class="id" type="var">p</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">s_eq_li</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">find_map_subst</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">t</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) <span class="id" type="var">v_sigma</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">y</span>, <span class="id" type="var">t</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <span class="id" type="var">sigma</span>) = <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) <span class="id" type="var">v_sigma</span>  =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">y</span>, <span class="id" type="var">t</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <span class="id" type="var">sigma</span>) = <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Some</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">y</span>, <span class="id" type="var">t</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">x_val</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">s</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">generalize</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">s</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">s</span>;<br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">z</span> <span class="id" type="var">u</span>] <span class="id" type="var">sigma</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">s</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">z</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_eq_z</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_z</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_step_is_complete</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">theta</span>, <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>) <span class="id" type="var">theta</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">decomposition_step</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>)  <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb'</span> <span class="id" type="var">theta</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb'</span> <span class="id" type="var">theta</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> [ | [<span class="id" type="var">s</span> <span class="id" type="var">t</span>] <span class="id" type="var">l</span>]  <span class="id" type="var">sigma</span> <span class="id" type="var">theta</span>; <br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">decomposition_step</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <span class="id" type="var">cbv</span> <span class="id" type="var">iota</span> <span class="id" type="var">beta</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">T.eq_bool_ok</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">T.eq_bool</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">s_eq_t</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">s_diff_t</span>].<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>]; <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span> | <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hsigma</span>]; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">x</span> | <span class="id" type="var">f</span> <span class="id" type="var">l1</span> ]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">y</span> | <span class="id" type="var">g</span> <span class="id" type="var">l2</span> ].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hx</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>]; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hx</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>]; <br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Htheta</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>; [<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l'</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hl</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="tactic">f_equal</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">l</span> =&gt; <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); <span class="id" type="tactic">induction</span> <span class="id" type="var">l'</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s'</span> <span class="id" type="var">l'</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IH</span> <span class="id" type="var">s'</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl'</span>; <span class="id" type="tactic">trivial</span>;<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hx</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">destruct</span> (<span class="id" type="var">in_inv</span> <span class="id" type="var">H</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">s_t_eq_y_x_val'</span> | <span class="id" type="var">s_t_in_l'</span>]; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span>:=Hsigma <span class="id" type="var">x</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>;<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_y_x_val'</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">s_t_eq_y_x_val'</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>;<br/>
<span class="id" type="tactic">rewrite</span> &lt;-  (<span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H'</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Htheta</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">in_map_iff</span> <span class="id" type="keyword">in</span> <span class="id" type="var">s_t_in_l'</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">s_t_in_l'</span> <span class="id" type="keyword">as</span> [[<span class="id" type="var">s'</span> <span class="id" type="var">t'</span>] [<span class="id" type="var">H</span> <span class="id" type="var">s'_t'_in_l</span>]];<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Htheta</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hl</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span> ];<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Htheta</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">exact</span> <span class="id" type="var">I</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>]; <br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Htheta</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>; [<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l'</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hl</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="tactic">f_equal</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">l</span> =&gt; <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); <span class="id" type="tactic">induction</span> <span class="id" type="var">l'</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s'</span> <span class="id" type="var">l'</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IH</span> <span class="id" type="var">s'</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl'</span>; <span class="id" type="tactic">trivial</span>;<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hx</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">s_t_in_l'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">in_map_iff</span> <span class="id" type="keyword">in</span> <span class="id" type="var">s_t_in_l'</span>;<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s_t_in_l'</span> <span class="id" type="keyword">as</span> [[<span class="id" type="var">s'</span> <span class="id" type="var">t'</span>] [<span class="id" type="var">H</span> <span class="id" type="var">s'_t'_in_l</span>]]; <br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Htheta</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hl</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span> ];<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Htheta</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">exact</span> <span class="id" type="var">I</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span>| <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">x_val</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">L</span> | <span class="id" type="var">L</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_x_val_g_l2</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_x_val_g_l2</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_x_val_g_l2</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_x_val_g_l2</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">s_t_in_l</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">apply</span> ((<span class="id" type="var">proj1</span> <span class="id" type="var">H</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">apply</span> ((<span class="id" type="var">proj2</span> <span class="id" type="var">H</span>) <span class="id" type="var">z</span>).<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">y_val</span> <span class="id" type="var">y_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_sigma</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">y_val</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">L</span> | <span class="id" type="var">L</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_y_val_f_l1</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_y_val_f_l1</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>)).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_y_val_f_l1</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_y_val_f_l1</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>)).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">s_t_in_l</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">proj1</span> <span class="id" type="var">H</span>); <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> ((<span class="id" type="var">proj1</span> <span class="id" type="var">H</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">apply</span> ((<span class="id" type="var">proj2</span> <span class="id" type="var">H</span>) <span class="id" type="var">z</span>).<br/>

<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">F.Symb.eq_bool_ok</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">F.Symb.eq_bool</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">f_eq_g</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">f_diff_g</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">intro</span> <span class="id" type="var">L</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">split</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hl'</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>, <span class="id" type="var">In</span> (<span class="id" type="var">s</span>,t) <span class="id" type="var">l</span> -&gt; <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">s</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span>).<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hl12</span> : <span class="id" type="var">map</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span>) <span class="id" type="var">l1</span> = <span class="id" type="var">map</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span>) <span class="id" type="var">l2</span>).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">Hsigma</span>; <span class="id" type="tactic">generalize</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">L</span> <span class="id" type="var">Hl'</span> <span class="id" type="var">Hl12</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">s_diff_t</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">L</span> <span class="id" type="var">Hl</span> <span class="id" type="var">Hl'</span> <span class="id" type="var">Hl12</span>; <br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s1</span> <span class="id" type="var">l1</span>]; <span class="id" type="tactic">intros</span> [ | <span class="id" type="var">s2</span> <span class="id" type="var">l2</span>] <span class="id" type="var">l</span> <span class="id" type="var">L</span> <span class="id" type="var">Hl</span> <span class="id" type="var">Hl12</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">s_t_in_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">s_t_in_l'</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">IHl1</span> <span class="id" type="var">l2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">s_t_in_l'</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">s_t_in_l'</span>.<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_s1_s2</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_s1_s2</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hl12</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">Hl12</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hl12</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">Hl12</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">_</span>]; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span> <span class="id" type="var">_</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">length_map</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span>)); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H'</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">length_map</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">_</span>]; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">f_diff_g</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_step_is_sound</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">theta</span>, <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">decomposition_step</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>)  <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb'</span> <span class="id" type="var">theta</span> -&gt; <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>) <span class="id" type="var">theta</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> =&gt; <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>)  <span class="id" type="var">theta</span> -&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb'</span> <span class="id" type="var">theta</span> -&gt; <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>) <span class="id" type="var">theta</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> [ | [<span class="id" type="var">s</span> <span class="id" type="var">t</span>] <span class="id" type="var">l</span>]  <span class="id" type="var">sigma</span> <span class="id" type="var">theta</span>; <br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">decomposition_step</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <span class="id" type="var">cbv</span> <span class="id" type="var">iota</span> <span class="id" type="var">beta</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">T.eq_bool_ok</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">T.eq_bool</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">s_eq_t</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">s_diff_t</span>].<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>]; <span class="id" type="tactic">split</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hsigma</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s'</span> <span class="id" type="var">t'</span> [<span class="id" type="var">s'_t'_eq_s_t</span> | <span class="id" type="var">s'_t'_in_l</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s'_t'_eq_s_t</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">s'</span> <span class="id" type="var">t'</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">x</span> | <span class="id" type="var">f</span> <span class="id" type="var">l1</span> ]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">y</span> | <span class="id" type="var">g</span> <span class="id" type="var">l2</span> ].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hx</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>]; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hx</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hx</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">x_theta_eq_y_theta</span> : <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>)).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Htheta</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>; [<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l'</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="tactic">f_equal</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">l</span> =&gt; <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); <span class="id" type="tactic">induction</span> <span class="id" type="var">l'</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s'</span> <span class="id" type="var">l'</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IH</span> <span class="id" type="var">s'</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl'</span>; <span class="id" type="tactic">trivial</span>;<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_x_y</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_x_y</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Htheta</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">in_map</span> (<span class="id" type="var">B</span>:= <span class="id" type="var">term</span>*term) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">uv</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span>) =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">u</span>,v) := <span class="id" type="var">uv</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,Var <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">u</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,Var <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v</span>)) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">s_t_in_l</span>).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Htheta</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>);<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span> ]; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Htheta</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hx</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">x_theta_eq_y_theta</span> : <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>)).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Htheta</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>; [<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l'</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="tactic">f_equal</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">l</span> =&gt; <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); <span class="id" type="tactic">induction</span> <span class="id" type="var">l'</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s'</span> <span class="id" type="var">l'</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IH</span> <span class="id" type="var">s'</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl'</span>; <span class="id" type="tactic">trivial</span>;<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_x_y</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_x_y</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Htheta</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">in_map</span> (<span class="id" type="var">B</span>:= <span class="id" type="var">term</span>*term) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">uv</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span>) =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">u</span>,v) := <span class="id" type="var">uv</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,Var <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">u</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,Var <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v</span>)) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">s_t_in_l</span>).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span>]; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Htheta</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">x_val</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">L</span> | <span class="id" type="var">L</span>];<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_x_g_l2</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_x_g_l2</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">x_val</span>).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_x_g_l2</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_x_g_l2</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">x_val</span>).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>]; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_x_g_l2</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_x_g_l2</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>;<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>;<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">y_val</span> <span class="id" type="var">y_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_sigma</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">y_val</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">L</span> | <span class="id" type="var">L</span>];<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_f_l1_y</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_f_l1_y</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">y_val</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">y</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_diff_y</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">y_diff_y</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_f_l1_y</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_f_l1_y</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">trans_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">y_val</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>]; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_f_l1_y</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_f_l1_y</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>;<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">y</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_diff_y</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">y_diff_y</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsigma</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">F.Symb.eq_bool_ok</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">F.Symb.eq_bool</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">f_eq_g</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">f_diff_g</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">intro</span> <span class="id" type="var">L</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">split</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> ((<span class="id" type="keyword">forall</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>, <span class="id" type="var">In</span> (<span class="id" type="var">s</span>,t) <span class="id" type="var">l</span> -&gt; <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">s</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">map</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span>) <span class="id" type="var">l1</span> = <span class="id" type="var">map</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span>) <span class="id" type="var">l2</span>).<br/>
<span class="id" type="tactic">generalize</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">L</span>  <span class="id" type="var">Hl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">l2</span> <span class="id" type="var">L</span> <span class="id" type="var">l</span> <span class="id" type="var">Hl</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s1</span> <span class="id" type="var">l1</span>];<br/>
<span class="id" type="tactic">intros</span> [ | <span class="id" type="var">s2</span> <span class="id" type="var">l2</span>] <span class="id" type="var">l</span> <span class="id" type="var">L</span> <span class="id" type="var">Hl</span>.<br/>
<span class="id" type="tactic">split</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> : <span class="id" type="var">term</span>, <span class="id" type="var">In</span> (<span class="id" type="var">s</span>, <span class="id" type="var">t</span>) ((<span class="id" type="var">s1</span>,s2) :: <span class="id" type="var">l</span>) -&gt; <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">s</span> = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> <span class="id" type="var">t</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">proj1</span> (<span class="id" type="var">IHl1</span> <span class="id" type="var">l2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">s_t_in_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">H</span> <span class="id" type="var">s1</span> <span class="id" type="var">s2</span>); [<span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span> | <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">proj2</span> (<span class="id" type="var">IHl1</span> <span class="id" type="var">l2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hl</span>)).<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> [<span class="id" type="var">s_t_eq_f_l1_g_l2</span> | <span class="id" type="var">s_t_in_l</span>].<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">s_t_eq_f_l1_g_l2</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">_</span> <span class="id" type="var">H</span> ]; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">H</span> <span class="id" type="var">_</span> ]; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">apply</span> <span class="id" type="var">sym_eq</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">length_map</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span>)));<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Abs</span> := <span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">Abs</span>;<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">Hl</span> <span class="id" type="var">Hsigma</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">f_diff_g</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">Abs</span> := <span class="id" type="var">Hl</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">Abs</span>;<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">andb</span>  (<span class="id" type="var">negb</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">negb</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>)))))<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span> <span class="id" type="var">x</span>, <span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">x</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>) = <span class="id" type="var">true</span>  &lt;-&gt;   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ (<span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>)) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ (<span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solved_var</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_A</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_val</span> | ]; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> <span class="id" type="var">G</span>];<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">G'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">G</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">not_solved_var</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span> <span class="id" type="var">x</span>, <span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">x</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>) = <span class="id" type="var">false</span>  &lt;-&gt;   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">_</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>)) \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solved_var</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_A</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_val</span> | ]; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | <span class="id" type="var">G</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H'</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>))); <span class="id" type="tactic">intro</span> <span class="id" type="var">G'</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))); <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">G'</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab115"></a><h2 class="section">A measure on lists based on a measure on elements.</h2>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">TermMul</span> := <span class="id" type="var">dickson.Make</span>(<span class="id" type="var">Term_eq_dec</span>).<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">list_size_mul</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Set</span>) (<span class="id" type="var">siz</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="var">nat</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">A</span>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">l</span>} : <span class="id" type="var">list</span> <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; @<span class="id" type="var">nil</span> <span class="id" type="var">nat</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">h</span> :: <span class="id" type="var">tl</span> =&gt; (<span class="id" type="var">siz</span> <span class="id" type="var">h</span>) :: (<span class="id" type="var">list_size_mul</span> <span class="id" type="var">A</span> <span class="id" type="var">siz</span> <span class="id" type="var">tl</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt_mul</span> : (<span class="id" type="var">relation</span> (<span class="id" type="var">list</span> <span class="id" type="var">nat</span>)) := <br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">trans_clos</span> (<span class="id" type="var">NatMul.multiset_extension_step</span> <span class="id" type="var">lt</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">size_of_unsolved_part</span> <span class="id" type="var">pb</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">list_size_mul</span> <span class="id" type="var">_</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">s_t</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">s</span>,t) =&gt; <span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t</span>) <span class="id" type="keyword">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">size_of_solved_part</span> <span class="id" type="var">pb</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">list_size_mul</span> <span class="id" type="var">_</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> =&gt; <span class="id" type="var">size</span> <span class="id" type="var">x_val</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.support</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>))).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">nb_var_eq_of_unsolved_part</span> <span class="id" type="var">pb</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">list_size</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">s_t</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">s</span>,t) =&gt; <span class="id" type="keyword">match</span> <span class="id" type="var">s</span>, <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Var</span> <span class="id" type="var">_</span>,  <span class="id" type="var">_</span> =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> , <span class="id" type="var">Var</span> <span class="id" type="var">_</span> =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <span class="id" type="keyword">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>).<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">VSet_compat</span> : <br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">pb</span> (<span class="id" type="var">e</span> <span class="id" type="var">e'</span> : <span class="id" type="var">DecVar.A</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">DecVar.eq_A</span> <span class="id" type="var">e</span> <span class="id" type="var">e'</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">negb</span> (<span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">v</span> <span class="id" type="var">pb</span>)) <span class="id" type="var">e</span> =<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">negb</span> (<span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">v</span> <span class="id" type="var">pb</span>)) <span class="id" type="var">e'</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.EDS.eq_A</span>, <span class="id" type="var">DecVar.eq_A</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">phi1</span> <span class="id" type="var">pb</span> :=<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.cardinal</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.filter</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">v</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">negb</span> (<span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">v</span> <span class="id" type="var">pb</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.union</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.union</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet_compat</span> <span class="id" type="var">pb</span>)).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">phi2</span> <span class="id" type="var">pb</span> :=  <span class="id" type="var">size_of_solved_part</span> <span class="id" type="var">pb</span> ++ <span class="id" type="var">size_of_unsolved_part</span> <span class="id" type="var">pb</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">phi3</span> <span class="id" type="var">pb</span> := <span class="id" type="var">nb_var_eq_of_unsolved_part</span> <span class="id" type="var">pb</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">measure_for_unif_pb</span> <span class="id" type="var">pb</span> := (<span class="id" type="var">phi1</span> <span class="id" type="var">pb</span>, (<span class="id" type="var">phi2</span> <span class="id" type="var">pb</span>, <span class="id" type="var">phi3</span> <span class="id" type="var">pb</span>)).<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">lt_bool</span> (<span class="id" type="var">n1</span> <span class="id" type="var">n2</span> : <span class="id" type="var">nat</span>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">n1</span>} :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n1</span>, <span class="id" type="var">n2</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>, <span class="id" type="var">O</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span>, (<span class="id" type="var">S</span> <span class="id" type="var">_</span>) =&gt; <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">S</span> <span class="id" type="var">m1</span>), (<span class="id" type="var">S</span> <span class="id" type="var">m2</span>) =&gt; <span class="id" type="var">lt_bool</span> <span class="id" type="var">m1</span> <span class="id" type="var">m2</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">S</span> <span class="id" type="var">_</span>), <span class="id" type="var">O</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">lt_bool_ok</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span>, <span class="id" type="keyword">if</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="keyword">then</span> <span class="id" type="var">n1</span> &lt; <span class="id" type="var">n2</span> <span class="id" type="keyword">else</span> ~n1 &lt; <span class="id" type="var">n2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">fix</span> 1.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">n1</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">n1</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">n1</span>.<br/>
<span class="id" type="tactic">intros</span> [ | <span class="id" type="var">n2</span>]; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">lt_irrefl</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_O_n</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">n1</span> [ | <span class="id" type="var">n2</span>]; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">le_Sn_O</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">lt_bool</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span>).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">H1</span> <span class="id" type="var">H2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_S_n</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt_ms_bool</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">p123</span> <span class="id" type="var">q123</span> =&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">p123</span>, <span class="id" type="var">q123</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">p1</span>,(p2,p3)), (<span class="id" type="var">q1</span>,(q2,q3)) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">beq_nat</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">match</span> <span class="id" type="var">dickson.NatMul.mult</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">p2</span> <span class="id" type="var">q2</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Less_than</span> =&gt; <span class="id" type="var">true</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Equivalent</span> =&gt; <span class="id" type="var">lt_bool</span> <span class="id" type="var">p3</span> <span class="id" type="var">q3</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt_ms</span> <span class="id" type="var">m1</span> <span class="id" type="var">m2</span> := <span class="id" type="var">lt_ms_bool</span> <span class="id" type="var">m1</span> <span class="id" type="var">m2</span> = <span class="id" type="var">true</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt_pb</span> <span class="id" type="var">pb</span> <span class="id" type="var">pb'</span> := <br/>
<span class="id" type="var">lt_ms</span> (<span class="id" type="var">measure_for_unif_pb</span> <span class="id" type="var">pb</span>) (<span class="id" type="var">measure_for_unif_pb</span> <span class="id" type="var">pb'</span>).<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">lex_lt</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">p1</span> <span class="id" type="var">p2</span> <span class="id" type="var">p3</span> <span class="id" type="var">q1</span> <span class="id" type="var">q2</span> <span class="id" type="var">q3</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">p1</span> &lt; <span class="id" type="var">q1</span> -&gt; <span class="id" type="var">lt_ms</span> (<span class="id" type="var">p1</span>,(p2,p3)) (<span class="id" type="var">q1</span>,(q2,q3)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">p1</span> <span class="id" type="var">p2</span> <span class="id" type="var">p3</span> <span class="id" type="var">q1</span> <span class="id" type="var">q2</span> <span class="id" type="var">q3</span> <span class="id" type="var">p1_lt_q1</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_ms</span>, <span class="id" type="var">lt_ms_bool</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">p1_eq_q1</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">p1_diff_q1</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">absurd</span> (<span class="id" type="var">S</span> <span class="id" type="var">p1</span> &lt;= <span class="id" type="var">p1</span>); <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">lt_bool</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>).<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">lex_le_lt</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">p1</span> <span class="id" type="var">p2</span> <span class="id" type="var">p3</span> <span class="id" type="var">q1</span> <span class="id" type="var">q2</span> <span class="id" type="var">q3</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">p1</span> &lt;= <span class="id" type="var">q1</span> -&gt; <span class="id" type="var">dickson.NatMul.mult</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">p2</span> <span class="id" type="var">q2</span> = <span class="id" type="var">Less_than</span> -&gt; <span class="id" type="var">lt_ms</span> (<span class="id" type="var">p1</span>,(p2,p3)) (<span class="id" type="var">q1</span>,(q2,q3)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">p1</span> <span class="id" type="var">p2</span> <span class="id" type="var">p3</span> <span class="id" type="var">q1</span> <span class="id" type="var">q2</span> <span class="id" type="var">q3</span> <span class="id" type="var">p1_le_q1</span> <span class="id" type="var">p2_lt_q2</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_ms</span>, <span class="id" type="var">lt_ms_bool</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">p1_eq_q1</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">p1_diff_q1</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">p2_lt_q2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">lt_bool</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>).<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">p1_diff_q1</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">p1_diff_q1</span>; <span class="id" type="var">revert</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span> <span class="id" type="var">p1_le_q1</span> <span class="id" type="var">Abs</span> ; <span class="id" type="var">fix</span> 1.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">p1</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">p1</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">p1</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">q1</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">q1</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">q1</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_O_n</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">q1</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">q1</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">Abs</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">q1</span> <span class="id" type="var">Hle</span> <span class="id" type="var">Hnot_lt</span>; <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">lex_le_lt</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">le_S_n</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hnot_lt</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">lex_le_meq_lt</span> : <br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">p1</span> <span class="id" type="var">p2</span> <span class="id" type="var">p3</span> <span class="id" type="var">q1</span> <span class="id" type="var">q2</span> <span class="id" type="var">q3</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">p1</span> &lt;= <span class="id" type="var">q1</span> -&gt; <span class="id" type="var">dickson.NatMul.mult</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">p2</span> <span class="id" type="var">q2</span> = <span class="id" type="var">Equivalent</span> -&gt; <span class="id" type="var">p3</span> &lt; <span class="id" type="var">q3</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">lt_ms</span> (<span class="id" type="var">p1</span>,(p2,p3)) (<span class="id" type="var">q1</span>,(q2,q3)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">p1</span> <span class="id" type="var">p2</span> <span class="id" type="var">p3</span> <span class="id" type="var">q1</span> <span class="id" type="var">q2</span> <span class="id" type="var">q3</span> <span class="id" type="var">p1_le_q1</span> <span class="id" type="var">p2_eq_q2</span> <span class="id" type="var">p3_lt_q3</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_ms</span>, <span class="id" type="var">lt_ms_bool</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">p2_eq_q2</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">p1_eq_q1</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">p1_diff_q1</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">p3</span> <span class="id" type="var">q3</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">lt_bool</span> <span class="id" type="var">p3</span> <span class="id" type="var">q3</span>).<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span> <span class="id" type="var">p1_le_q1</span> <span class="id" type="var">p1_diff_q1</span> ; <span class="id" type="var">fix</span> 1.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">p1</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">p1</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">p1</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">q1</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">q1</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">q1</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">q1</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">p1</span> <span class="id" type="var">q1</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">q1</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">q1</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">Abs</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">q1</span> <span class="id" type="var">Hle</span> <span class="id" type="var">Hdiff</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_le_meq_lt</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">le_S_n</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Heq</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hdiff</span>; <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">wf_lt_ms</span> : <span class="id" type="var">well_founded</span> <span class="id" type="var">lt_ms</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">well_founded</span>, <span class="id" type="var">lt_ms</span>, <span class="id" type="var">lt_ms_bool</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">p</span> [<span class="id" type="var">q</span> <span class="id" type="var">r</span>]]; <span class="id" type="var">revert</span> <span class="id" type="var">q</span> <span class="id" type="var">r</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">p</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">well_founded_ind</span> <span class="id" type="var">lt_wf</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">p</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">p</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">p</span> <span class="id" type="var">IHp</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_mul</span>.<br/>
<span class="id" type="tactic">pattern</span> <span class="id" type="var">q</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">well_founded_ind</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">list</span> <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;(<span class="id" type="var">trans_clos</span> (<span class="id" type="var">NatMul.multiset_extension_step</span> <span class="id" type="var">lt</span>)); <span class="id" type="tactic">clear</span> <span class="id" type="var">q</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">closure.wf_trans</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.dickson</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Wf_nat.lt_wf</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">q</span> <span class="id" type="var">IHq</span> <span class="id" type="var">r</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">r</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">well_founded_ind</span> <span class="id" type="var">Wf_nat.lt_wf</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">r</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">r</span>.<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">r</span> <span class="id" type="var">IHr</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Acc_intro</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">p'</span> [<span class="id" type="var">q'</span> <span class="id" type="var">r'</span>]]; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> <span class="id" type="var">p'</span> <span class="id" type="var">p</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">p'</span> <span class="id" type="var">p</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">p'_eq_p</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">p'_diff_p</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">p'</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">NatMul.mult</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">q'</span> <span class="id" type="var">q</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">q'_eq_q</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">q'_lt_q</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">q'_gt_q</span>  | <span class="id" type="tactic">intro</span> <span class="id" type="var">q'_diff_q</span> ].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">r'_lt_r</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">r'</span> <span class="id" type="var">r</span>); <span class="id" type="tactic">rewrite</span>  <span class="id" type="var">r'_lt_r</span>; <span class="id" type="tactic">clear</span>  <span class="id" type="var">r'_lt_r</span>; <span class="id" type="tactic">intro</span>  <span class="id" type="var">r'_lt_r</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Acc_p_q_r'</span> := <span class="id" type="var">IHr</span> <span class="id" type="var">_</span> <span class="id" type="var">r'_lt_r</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Acc_intro</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">p''</span> [<span class="id" type="var">q''</span> <span class="id" type="var">r''</span>]].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> <span class="id" type="var">p''</span> <span class="id" type="var">p</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">p''</span> <span class="id" type="var">p</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">p''_eq_p</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">p''_diff_p</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">p''</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">NatMul.mult</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">q''</span> <span class="id" type="var">q'</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">q''_eq_q'</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">q''_lt_q'</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">q''_gt_q'</span>  | <span class="id" type="tactic">intro</span> <span class="id" type="var">q''_diff_q'</span> ].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">r''_lt_r'</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">Acc_inv</span> <span class="id" type="var">Acc_p_q_r'</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">beq_nat_refl</span> <span class="id" type="var">p</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">q''_eq_q</span> : <span class="id" type="var">NatMul.mult</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">q''</span> <span class="id" type="var">q</span> = <span class="id" type="var">Equivalent</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.mult_is_complete_equiv</span>.<br/>
<span class="id" type="tactic">transitivity</span> <span class="id" type="var">q'</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">NatMul.mult_is_sound</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>  <span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">q''</span> <span class="id" type="var">q'</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">q''_eq_q'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">NatMul.mult_is_sound</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">q'</span> <span class="id" type="var">q</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">q'_eq_q</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">q''_eq_q</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">q''_lt_q</span> : <span class="id" type="var">NatMul.mult</span> <span class="id" type="var">lt_bool</span> <span class="id" type="var">q''</span> <span class="id" type="var">q</span> = <span class="id" type="var">Less_than</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">NatMul.mult_is_sound</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>  <span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">q'</span> <span class="id" type="var">q</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">q'_eq_q</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> := <span class="id" type="var">NatMul.mult_is_sound</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">q''</span> <span class="id" type="var">q'</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">q''_lt_q'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H''</span> : <span class="id" type="var">trans_clos</span> (<span class="id" type="var">NatMul.multiset_extension_step</span> <span class="id" type="var">lt</span>) <span class="id" type="var">q''</span> <span class="id" type="var">q</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.list_permut_trans_clos_multiset_extension_step_2</span> <span class="id" type="keyword">with</span> <span class="id" type="var">q'</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H3</span> := <span class="id" type="var">NatMul.mult_is_sound</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">q''</span> <span class="id" type="var">q</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.mult_is_complete_less_than</span> <span class="id" type="keyword">with</span> <span class="id" type="var">lt</span>.<br/>
<span class="id" type="tactic">exact</span> <span class="id" type="var">lt_bool_ok</span>.<br/>
<span class="id" type="tactic">exact</span> <span class="id" type="var">lt_trans</span>.<br/>
<span class="id" type="tactic">exact</span> <span class="id" type="var">lt_irrefl</span>.<br/>
<span class="id" type="tactic">assumption</span>.<br/>

<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHq</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">NatMul.mult_is_sound</span> <span class="id" type="var">lt</span> <span class="id" type="var">_</span> <span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">q''</span> <span class="id" type="var">q</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">q''_lt_q</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">p''_lt_p</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHp</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">p''</span> <span class="id" type="var">p</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">p''_lt_p</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHq</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">NatMul.mult_is_sound</span>  <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">q'</span> <span class="id" type="var">q</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">q'_lt_q</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">exact</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">p'_lt_p</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHp</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">lt_bool_ok</span> <span class="id" type="var">p'</span> <span class="id" type="var">p</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">p'_lt_p</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">wf_lt_pb</span> : <span class="id" type="var">well_founded</span> <span class="id" type="var">lt_pb</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>;<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">wf_inverse_image</span> <span class="id" type="var">unification_problem</span> <span class="id" type="var">_</span> <span class="id" type="var">lt_ms</span> <span class="id" type="var">measure_for_unif_pb</span> <span class="id" type="var">wf_lt_ms</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">remove_trivial_eq_decreases</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">s</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>,  <span class="id" type="var">lt_pb</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>) (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>,s) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>;<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>, <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_le_lt</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.cardinal_subset</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_compat_subset_1</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">v</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>)).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> : <span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">v</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>, <span class="id" type="var">s</span>) :: <span class="id" type="var">l</span>)) = <span class="id" type="var">false</span>).<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>].<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H'</span>; <span class="id" type="tactic">reflexivity</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_mul</span>, <span class="id" type="var">phi2</span>, <span class="id" type="var">size_of_unsolved_part</span>, <span class="id" type="var">size_of_solved_part</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">NatMul.mult_is_complete_less_than</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">lt_bool_ok</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="var">n3</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lt_trans</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">lt_irrefl</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">refine</span> (@<span class="id" type="var">NatMul.rmv_case</span> <span class="id" type="var">lt</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">list_size_mul</span> <span class="id" type="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span>  =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> =&gt; <span class="id" type="var">size</span> <span class="id" type="var">x_val</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>) (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)) ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">list_size_mul</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">s0</span>, <span class="id" type="var">t</span>) := <span class="id" type="var">s_t</span> <span class="id" type="keyword">in</span> <span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s0</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t</span>)) <span class="id" type="var">l</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">nil</span> (<span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s</span>) (<span class="id" type="var">size</span> <span class="id" type="var">s</span>)) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">symmetry</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;-  <span class="id" type="var">NatMul.LP.permut_cons_inside</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">domain_of_subst_map_subst</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">f</span>, <span class="id" type="var">domain_of_subst</span> (<span class="id" type="var">map_subst</span> <span class="id" type="var">f</span> <span class="id" type="var">sigma</span>) = <span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">f</span>; <br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">x</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>]; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_inc_not_mem</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">t</span>,  <span class="id" type="var">x</span> &lt;&gt; <span class="id" type="var">y</span> -&gt;  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~ <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">set_of_variables</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">t</span> <span class="id" type="var">x_diff_y</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">T.term_rec3</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_nil</span>] ; [<span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_y</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">x_eq_v</span> | <span class="id" type="var">x_in_nil</span>].<br/>
<span class="id" type="tactic">unfold</span>  <span class="id" type="var">VSet.LP.EDS.eq_A</span>, <span class="id" type="var">VSet.EDS.eq_A</span>, <span class="id" type="var">DecVar.eq_A</span> <span class="id" type="keyword">in</span> *;<br/>
<span class="id" type="tactic">subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">v_diff_x</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">IHl</span> <span class="id" type="var">x_in_l'</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_l'</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">f</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s</span> <span class="id" type="var">l</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_l'</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_l'</span> <span class="id" type="var">x_in_s'</span> <span class="id" type="var">x_in_l''</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">IHl</span> <span class="id" type="var">s</span>); <span class="id" type="tactic">trivial</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHl0</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_inc_not_mem_list</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">l</span>,  <span class="id" type="var">x</span> &lt;&gt; <span class="id" type="var">y</span> -&gt;  <br/>
&nbsp;&nbsp;~ <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_unsolved_part</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uv</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">u</span>, <span class="id" type="var">v</span>) := <span class="id" type="var">uv</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">u</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v</span>)) <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">l</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_l'</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">s</span> <span class="id" type="var">t</span>] <span class="id" type="var">l</span>].<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_l'</span>; <br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_l'</span> <span class="id" type="var">x_in_s'_t'</span> <span class="id" type="var">x_in_l''</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_s'_t'</span> <span class="id" type="var">x_in_s'</span> <span class="id" type="var">x_in_t'</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_not_mem</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_s'</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_not_mem</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_t'</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_inc_not_mem_subst</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>,  <span class="id" type="var">x</span> &lt;&gt; <span class="id" type="var">y</span> -&gt;  <br/>
&nbsp;&nbsp;~VSet.<span class="id" type="var">mem</span> <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_range_of_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">v_sigma</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_sigma'</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">v</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>].<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_sigma'</span>; <br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_sigma'</span> <span class="id" type="var">x_in_t'</span> <span class="id" type="var">x_in_sigma''</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_not_mem</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_t'</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_inc_occ_in_subst</span> : <br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">z</span> <span class="id" type="var">x_val</span> <span class="id" type="var">sigma</span>, <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">x_val</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">z</span> <span class="id" type="var">x_val</span> <span class="id" type="var">sigma</span>; <br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">v</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>].<br/>
<span class="id" type="tactic">intro</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x_sigma</span> <span class="id" type="var">z_in_x_val</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="var">revert</span> <span class="id" type="var">x_sigma</span>.<br/>
&nbsp;<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_inc_term</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">t</span>, <span class="id" type="var">z</span> &lt;&gt; <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">t</span> <span class="id" type="var">z_diff_y</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">T.term_rec3</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_eq_y</span> | <span class="id" type="var">z_in_nil</span>].<br/>
<span class="id" type="tactic">unfold</span>  <span class="id" type="var">VSet.LP.EDS.eq_A</span>, <span class="id" type="var">VSet.EDS.eq_A</span>, <span class="id" type="var">DecVar.eq_A</span> <span class="id" type="keyword">in</span> *;<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">z</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">y</span>=y); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="var">fold</span> <span class="id" type="var">set_of_variables_list</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">f</span>; <br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">s</span> <span class="id" type="var">l</span>]; [<span class="id" type="tactic">trivial</span> | <span class="id" type="var">idtac</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">H_s_l</span> <span class="id" type="var">z_in_s'_l'</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_s'_l'</span> <span class="id" type="var">z_in_s'</span> <span class="id" type="var">z_in_l'</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H_s_l</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H_s_l</span>;  [<span class="id" type="var">right</span> | <span class="id" type="var">idtac</span>] ; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_inc_list</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">l</span>,  <span class="id" type="var">z</span> &lt;&gt; <span class="id" type="var">y</span> -&gt;  <br/>
&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_unsolved_part</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uv</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">u</span>, <span class="id" type="var">v</span>) := <span class="id" type="var">uv</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">u</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v</span>)) <span class="id" type="var">l</span>)) -&gt;<br/>
&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">l</span> <span class="id" type="var">z_diff_y</span> <span class="id" type="var">z_in_l'</span>; <br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">s</span> <span class="id" type="var">t</span>] <span class="id" type="var">l</span>]; <span class="id" type="tactic">trivial</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l'</span> <span class="id" type="var">z_in_s'_t'</span> <span class="id" type="var">z_in_l''</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_s'_t'</span> <span class="id" type="var">z_in_s'</span> <span class="id" type="var">z_in_t'</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_term</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_term</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_inc_subst</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>,  <span class="id" type="var">z</span> &lt;&gt; <span class="id" type="var">y</span> -&gt;  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_range_of_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">v_sigma</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <span class="id" type="var">sigma</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span> <span class="id" type="var">z_diff_y</span> <span class="id" type="var">z_in_sigma'</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">v</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_sigma'</span> <span class="id" type="var">z_in_t'</span> <span class="id" type="var">z_in_sigma''</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_range_of_subst</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_term</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_range_of_subst</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">coalesce1_decreases</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_val</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">x</span> &lt;&gt; <span class="id" type="var">y</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">lt_pb</span> (<span class="id" type="var">mk_pb</span>  ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: <span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">v_sigma</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <span class="id" type="var">sigma</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">Var</span> <span class="id" type="var">y</span>, <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">x_val</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: <span class="id" type="var">map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uv</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">u</span>, <span class="id" type="var">v</span>) := <span class="id" type="var">uv</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">u</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v</span>)) <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">Var</span> <span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_diff_y</span>  <span class="id" type="var">x_sigma</span>; <br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hx</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hx</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>, <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_lt</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_cardinal_not_eq_not_eq_set</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hy</span> : <span class="id" type="var">VSet.mem</span> <span class="id" type="var">y</span> (<span class="id" type="var">VSet.union</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.union</span> (<span class="id" type="var">VSet.union</span> (<span class="id" type="var">VSet.singleton</span> <span class="id" type="var">x</span>) (<span class="id" type="var">VSet.singleton</span> <span class="id" type="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">VSet.union</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">set_of_variables_in_range_of_subst</span> <span class="id" type="var">sigma</span>)))).<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> [<span class="id" type="var">z_eq_y</span> | <span class="id" type="var">z_in_nil</span>].<br/>
<span class="id" type="tactic">unfold</span>  <span class="id" type="var">VSet.LP.EDS.eq_A</span>, <span class="id" type="var">VSet.EDS.eq_A</span>, <span class="id" type="var">DecVar.eq_A</span> <span class="id" type="keyword">in</span> *;<br/>
<span class="id" type="tactic">subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hy</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_x_val'</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hy</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">trivial</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_term</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_l'</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hy</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Hy</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_list</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_x_dom_sig</span>; <br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.add_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_x_dom_sig</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">z_eq_x</span> | <span class="id" type="var">z_in_dom_sig</span>].<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">domain_of_subst_map_subst</span> <span class="id" type="keyword">in</span> <span class="id" type="var">z_in_dom_sig</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> [<span class="id" type="var">z_eq_y</span> | <span class="id" type="var">z_in_nil</span>].<br/>
<span class="id" type="tactic">unfold</span>  <span class="id" type="var">VSet.LP.EDS.eq_A</span>, <span class="id" type="var">VSet.EDS.eq_A</span>, <span class="id" type="var">DecVar.eq_A</span> <span class="id" type="keyword">in</span> *;<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hy</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_sigma'</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hy</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_diff_y</span> <span class="id" type="var">z_in_sigma'</span>).<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>); <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="var">left</span>;  <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span>| <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span>]; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_in_y_x_val'_l'</span> | <span class="id" type="var">z_in_y_sigma'</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_x_val'_l'</span> <span class="id" type="var">z_in_y_x_val'</span> <span class="id" type="var">z_in_l'</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_x_val'</span> <span class="id" type="var">z_in_y</span> <span class="id" type="var">z_in_x_val'</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_term</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_list</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_sigma'</span> <span class="id" type="var">z_in_y</span> <span class="id" type="var">z_in_sigma'</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">VSet.filter_2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">_</span> <span class="id" type="var">H</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="var">revert</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">H</span> <span class="id" type="var">x_in_y_x_val'</span> <span class="id" type="var">x_in_l'</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_y_x_val'</span> <span class="id" type="var">x_in_y</span> <span class="id" type="var">x_in_x_val'</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_y</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_nil</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_y</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_not_mem</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_x_val'</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_not_mem_list</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_l'</span>).<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">H</span> <span class="id" type="var">x_in_y</span> <span class="id" type="var">x_in_sigma'</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_y</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_nil</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_y</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_not_mem_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_diff_y</span> <span class="id" type="var">x_in_sigma'</span>).<br/>

<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.filter_1</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span>;<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">coalesce2_decreases</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">x</span> &lt;&gt; <span class="id" type="var">y</span> -&gt; <br/>
&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">None</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">lt_pb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mk_pb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: <span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">v_sigma</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <span class="id" type="var">sigma</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uv</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> (<span class="id" type="var">u</span>, <span class="id" type="var">v</span>) := <span class="id" type="var">uv</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">u</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v</span>)) <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">Var</span> <span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_diff_y</span>  <span class="id" type="var">x_sigma</span>; <br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hx</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hx</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>, <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_lt</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_cardinal_not_eq_not_eq_set</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span>;<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">domain_of_subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_l'</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_list</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">domain_of_subst_map_subst</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_x_dom_sig</span>; <br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.add_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_x_dom_sig</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">z_eq_x</span> | <span class="id" type="var">z_in_dom_sig</span>].<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_y_sigma'</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_sigma'</span> <span class="id" type="var">z_in_y</span> <span class="id" type="var">z_in_sigma'</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_diff_y</span> <span class="id" type="var">z_in_sigma'</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>); <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_in_l'</span> | <span class="id" type="var">z_in_y_sigma'</span>].<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_list</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_sigma'</span> <span class="id" type="var">z_in_y</span> <span class="id" type="var">z_in_sigma'</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
&nbsp;<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.filter_2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">_</span> <span class="id" type="var">H1</span>]; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>; <span class="id" type="var">revert</span> <span class="id" type="var">H1</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">x_in_l'</span> | <span class="id" type="var">x_in_y_sigma'</span>].<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">x_in_l'</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_not_mem_list</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_y_sigma'</span> <span class="id" type="var">x_in_y</span> <span class="id" type="var">x_in_sigma'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_y</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_y</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_nil</span>]; [<span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_not_mem_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.filter_1</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span>; <br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">list_size_mul_app</span>:<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Set</span>) (<span class="id" type="var">siz</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="var">nat</span>) <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>,<br/>
&nbsp;<span class="id" type="var">list_size_mul</span> <span class="id" type="var">A</span> <span class="id" type="var">siz</span> (<span class="id" type="var">l1</span> ++ <span class="id" type="var">l2</span>) = (<span class="id" type="var">list_size_mul</span> <span class="id" type="var">A</span> <span class="id" type="var">siz</span> <span class="id" type="var">l1</span>) ++ <span class="id" type="var">list_size_mul</span> <span class="id" type="var">A</span> <span class="id" type="var">siz</span> <span class="id" type="var">l2</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">a1</span> <span class="id" type="var">l1</span> ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">merge1_decreases</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_val</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) &lt; <span class="id" type="var">size</span> <span class="id" type="var">x_val</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">lt_pb</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">sigma</span>) ((<span class="id" type="var">x_val</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">Var</span> <span class="id" type="var">x</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> <span class="id" type="var">L</span>; <br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>, <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_le_meq_lt</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) <span class="id" type="var">L</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">t2</span> <span class="id" type="var">L</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.cardinal_subset</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_x_val_t2_l</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2_l</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">x_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_x_val</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_sigma</span> <span class="id" type="var">z_in_x_val</span>).<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_x_dom_sig_t2_sigma</span>; <br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_dom_sig_t2_sigma</span> <span class="id" type="var">z_in_x_dom_sig</span> <span class="id" type="var">z_in_t2_sigma</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.add_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_x_dom_sig</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">z_in_x</span> | <span class="id" type="var">z_in_dom_sig</span>].<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t2_sigma</span> <span class="id" type="var">z_in_t2</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>); <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="var">left</span>; <br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span> ].<br/>
<span class="id" type="tactic">intros</span> [ <span class="id" type="var">z_in_x_val_t2_l</span> | <span class="id" type="var">z_in_t2_sigma</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2_l</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_x_val</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">z</span> <span class="id" type="var">x_val</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t2_sigma</span> <span class="id" type="var">z_in_t2</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) <span class="id" type="var">L</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">t2</span> <span class="id" type="var">L</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">x_in_dom_sig</span> : <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">y</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>].<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="var">revert</span> <span class="id" type="var">x_sigma</span>;<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_y</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_1</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_2</span>;<span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">mem_split_set</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_dom_sig</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [<span class="id" type="var">x'</span> [<span class="id" type="var">s1</span> [<span class="id" type="var">s2</span> [<span class="id" type="var">x_eq_x'</span> [<span class="id" type="var">dom_sig_eq_s1_x_s2</span> <span class="id" type="var">_</span>]]]]];<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_eq_x'</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">dom_sig_eq_s1_x_s2</span>.<br/>
<span class="id" type="tactic">unfold</span>  <span class="id" type="var">VSet.LP.EDS.eq_A</span>, <span class="id" type="var">VSet.EDS.eq_A</span>, <span class="id" type="var">DecVar.eq_A</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">subst</span> <span class="id" type="var">x'</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi2</span>, <span class="id" type="var">size_of_solved_part</span>, <span class="id" type="var">size_of_unsolved_part</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">replace</span> (<span class="id" type="var">VSet.add</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)) <span class="id" type="keyword">with</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">max_l</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">dom_sig_eq_s1_x_s2</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">list_size_mul_app</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">size_ge_one</span> <span class="id" type="var">t2</span>); <span class="id" type="tactic">destruct</span> (<span class="id" type="var">size</span> <span class="id" type="var">t2</span>) <span class="id" type="keyword">as</span> [ | <span class="id" type="var">n2</span>]; <br/>
[<span class="id" type="tactic">intro</span>; <span class="id" type="var">absurd</span> (1 &lt;= 0); <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> ].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.mult_is_complete_equiv</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">ass_app</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">app_comm_cons</span>;<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">NatMul.LP.permut_add_inside</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">ass_app</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">app_comm_cons</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">ass_app</span>;<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">NatMul.LP.permut_add_inside</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">ass_app</span>;<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">NatMul.LP.permut_app2</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">list_size_mul_app</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">x_not_in_s1_s2</span> : ~mem (@<span class="id" type="var">eq</span> <span class="id" type="var">_</span>) <span class="id" type="var">x</span> (<span class="id" type="var">s1</span> ++ <span class="id" type="var">s2</span>)).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">W</span> := <span class="id" type="var">VSet.is_a_set</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">dom_sig_eq_s1_x_s2</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">P</span> : <span class="id" type="var">VSet.LP.permut</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">s1</span> ++ <span class="id" type="var">s2</span>) (<span class="id" type="var">s1</span> ++ <span class="id" type="var">x</span> :: <span class="id" type="var">s2</span>)).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">VSet.LP.permut_cons_inside</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">W''</span> := <span class="id" type="var">VSet.without_red_permut</span> <span class="id" type="var">W</span> (<span class="id" type="var">VSet.LP.permut_sym</span> <span class="id" type="var">P</span>)).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">VSet.without_red_permut</span> <span class="id" type="var">W</span> (<span class="id" type="var">VSet.LP.permut_sym</span> <span class="id" type="var">P</span>)).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.without_red</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.A</span>, <span class="id" type="var">DecVar.eq_bool</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> (<span class="id" type="var">s1</span> ++ <span class="id" type="var">s2</span>)); <span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> (<span class="id" type="var">s1</span> ++ <span class="id" type="var">s2</span>)).<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">s1</span> ++ <span class="id" type="var">s2</span>) <span class="id" type="var">x_not_in_s1_s2</span>;<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">x_not_in_s</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">s</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">v</span> <span class="id" type="var">s</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.LP.permut_refl</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="var">absurd</span> (<span class="id" type="var">mem</span> (@<span class="id" type="var">eq</span> <span class="id" type="var">_</span>) <span class="id" type="var">x</span> (<span class="id" type="var">v</span> :: <span class="id" type="var">s</span>)); <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">NatMul.LP.permut_cons</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHs</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_not_in_s</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">VSet.already_mem_add</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">dom_sig_eq_s1_x_s2</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">mem_or_app</span>; <span class="id" type="var">right</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi3</span>, <span class="id" type="var">nb_var_eq_of_unsolved_part</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">x_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l1</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">L'</span> := <span class="id" type="var">le_Sn_O</span> <span class="id" type="var">_</span> (<span class="id" type="var">lt_S_n</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">L</span>)); <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Inv_solved_part</span> <span class="id" type="var">pb</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, <span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span>.(<span class="id" type="var">solved_part</span>) <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">Var</span> <span class="id" type="var">_</span>) =&gt; <span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">x</span> <span class="id" type="var">pb</span> = <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">merge2_decreases</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_val</span>, <br/>
&nbsp;<span class="id" type="var">Inv_solved_part</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">Var</span> <span class="id" type="var">x</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) &gt;= <span class="id" type="var">size</span> <span class="id" type="var">x_val</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">lt_pb</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">x_val</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>)) (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">Var</span> <span class="id" type="var">x</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_val</span> <span class="id" type="var">Inv_pb</span> <span class="id" type="var">x_sigma</span> <span class="id" type="var">L</span>; <br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">x_in_dom_sig</span> : <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">y</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>].<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="var">revert</span> <span class="id" type="var">x_sigma</span>;<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">x</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_y</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_1</span>.<br/>
<span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.add_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>, <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_le_meq_lt</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) <span class="id" type="var">L</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">L</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">t2</span> <span class="id" type="var">L</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.cardinal_subset</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_x_val_t2_l</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2_l</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_x_val</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_sigma</span> <span class="id" type="var">z_in_x_val</span>).<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_dom_sig</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_sigma</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>); <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [ <span class="id" type="var">z_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_in_x_val_t2_l</span>  | <span class="id" type="var">z_in_sigma</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2_l</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_x_val</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">z</span> <span class="id" type="var">x_val</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi2</span>, <span class="id" type="var">size_of_unsolved_part</span>, <span class="id" type="var">size_of_solved_part</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) <span class="id" type="var">L</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">L</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">t2</span> <span class="id" type="var">L</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">max_r</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">unfold</span> <span class="id" type="var">ge</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">size_ge_one</span> <span class="id" type="var">t2</span>); <span class="id" type="tactic">destruct</span> (<span class="id" type="var">size</span> <span class="id" type="var">t2</span>) <span class="id" type="keyword">as</span> [ | <span class="id" type="var">n2</span>]; <br/>
[<span class="id" type="tactic">intro</span>; <span class="id" type="var">absurd</span> (1&lt;=0); <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.mult_is_complete_equiv</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.LP.permut_refl</span>.<br/>

<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">x_val</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l'</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>.<br/>
<span class="id" type="tactic">intros</span> [ <span class="id" type="var">H</span> <span class="id" type="var">_</span> ]; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">move_eq_decreases</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">None</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">lt_pb</span> (<span class="id" type="var">mk_pb</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">sigma</span>) <span class="id" type="var">l</span>) (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">Var</span> <span class="id" type="var">x</span>, <span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x_sigma</span>; <br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>, <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_le_meq_lt</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">t2</span>;<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.cardinal_subset</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>.<br/>
<span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_x_dom_sig</span>; <br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.add_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_x_dom_sig</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">z_eq_x</span> | <span class="id" type="var">z_in_dom_sig</span>].<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_t2</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_sigma</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>); <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">z_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_in_l</span> | <span class="id" type="var">z_in_t2_sigma</span>].<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t2_sigma</span> <span class="id" type="var">z_in_t2</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.mult_is_complete_equiv</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi2</span>, <span class="id" type="var">size_of_solved_part</span>, <span class="id" type="var">size_of_unsolved_part</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">t2</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">x_not_in_dom_sig</span> : ~ <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">y</span> <span class="id" type="var">t</span>] <span class="id" type="var">sigma</span>].<br/>
<span class="id" type="tactic">intro</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_in_y_dom_sig</span>;<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.add_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_y_dom_sig</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_dom_sig</span>];<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">x_in_y_dom_sig</span>.<br/>
<span class="id" type="tactic">unfold</span>  <span class="id" type="var">VSet.LP.EDS.eq_A</span>, <span class="id" type="var">VSet.EDS.eq_A</span>, <span class="id" type="var">DecVar.eq_A</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">subst</span> <span class="id" type="var">y</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <br/>
[<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHsigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>

<br/>
<span class="id" type="tactic">replace</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">domain_of_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">t2</span>) :: <span class="id" type="var">sigma</span>))) <span class="id" type="keyword">with</span> (<span class="id" type="var">x</span> :: (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>))).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">size_ge_one</span> <span class="id" type="var">t2</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">size</span> <span class="id" type="var">t2</span>).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">lt_n_O</span> <span class="id" type="var">_</span> <span class="id" type="var">Abs</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">NatMul.LP.permut_cons_inside</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">NatMul.LP.permut_app2</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">l</span>; <span class="id" type="var">revert</span> <span class="id" type="var">x_not_in_dom_sig</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>, <span class="id" type="var">DecVar.eq_A</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)); <span class="id" type="var">fix</span> 1.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">case</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">a</span> <span class="id" type="var">l</span> <span class="id" type="var">x_not_in_al</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">a</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">a</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">a_eq_x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_not_in_al</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">NatMul.LP.permut_cons</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">move_eq_decreases</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_in_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_not_in_al</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">x_not_in_dom_sig</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.not_already_mem_add</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi3</span>, <span class="id" type="var">nb_var_eq_of_unsolved_part</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_decreases</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">lt_pb</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">combine</span> <span class="id" type="var">term</span> <span class="id" type="var">l</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>, <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>, <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lex_le_lt</span>.<br/>

<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">z</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> (<span class="id" type="var">combine</span> <span class="id" type="var">term</span> <span class="id" type="var">l</span> <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">set_of_variables_in_unsolved_part</span> ((<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>, <span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l2</span>) :: <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">set_of_variables_in_unsolved_part</span> <span class="id" type="tactic">at</span> 2.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">set_of_variables</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">t1</span> <span class="id" type="var">l1</span>]; <span class="id" type="tactic">intros</span> [ | <span class="id" type="var">t2</span> <span class="id" type="var">l2</span>] <span class="id" type="var">l</span> <span class="id" type="var">z</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">z_in_l1l2_t1t2l</span> := <span class="id" type="var">IHl1</span> <span class="id" type="var">l2</span> ((<span class="id" type="var">t1</span>,t2) :: <span class="id" type="var">l</span>) <span class="id" type="var">z</span> <span class="id" type="var">H</span>).<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l1l2_t1t2l</span> <span class="id" type="var">z_in_l1l2</span> <span class="id" type="var">z_in_t1t2l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l1l2</span> <span class="id" type="var">z_in_l1</span> <span class="id" type="var">z_in_l2</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t1t2l</span> <span class="id" type="var">z_in_t1t2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t1t2</span> <span class="id" type="var">z_in_t1</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.cardinal_subset</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_l1_l2_l</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">H</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_l1_l2_l</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">z_in_l1_l2_l</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_l1_l2_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l1_l2_l</span> <span class="id" type="var">z_in_l1_l2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l1_l2</span> <span class="id" type="var">z_in_l1</span> <span class="id" type="var">z_in_l2</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_subset_union</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_dom_sig</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_sigma</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">do</span> 2 (<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Dummy_bool</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>);<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">z_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> | <span class="id" type="var">H1</span>].<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.mult_is_complete_less_than</span> <span class="id" type="keyword">with</span> <span class="id" type="var">lt</span>.<br/>
<span class="id" type="tactic">exact</span> <span class="id" type="var">lt_bool_ok</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span> <span class="id" type="var">n3</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">lt_trans</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">lt_irrefl</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi2</span>, <span class="id" type="var">size_of_solved_part</span>, <span class="id" type="var">size_of_unsolved_part</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_mul</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.context_trans_clos_multiset_extension_step_app1</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">list_size_fold</span> <span class="id" type="var">size</span>).<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">t1</span> <span class="id" type="var">l1</span>]; <span class="id" type="tactic">intros</span> [ | <span class="id" type="var">t2</span> <span class="id" type="var">l2</span>] <span class="id" type="var">l</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">simpl</span>;<br/>
<span class="id" type="tactic">refine</span> (@<span class="id" type="var">NatMul.rmv_case</span> <span class="id" type="var">lt</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">list_size_mul</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt; <span class="id" type="keyword">let</span> (<span class="id" type="var">s</span>, <span class="id" type="var">t</span>) := <span class="id" type="var">s_t</span> <span class="id" type="keyword">in</span> <span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t</span>)) <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">nil</span> 1 <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>); <span class="id" type="tactic">try</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.LP.permut_refl</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">simpl</span>;<br/>
<span class="id" type="tactic">refine</span> (@<span class="id" type="var">NatMul.rmv_case</span> <span class="id" type="var">lt</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">list_size_mul</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt; <span class="id" type="keyword">let</span> (<span class="id" type="var">s</span>, <span class="id" type="var">t</span>) := <span class="id" type="var">s_t</span> <span class="id" type="keyword">in</span> <span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t</span>)) <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">nil</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>); <span class="id" type="tactic">try</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.LP.permut_refl</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="var">left</span>; <span class="id" type="tactic">simpl</span>;<br/>
<span class="id" type="tactic">refine</span> (@<span class="id" type="var">NatMul.rmv_case</span> <span class="id" type="var">lt</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">list_size_mul</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt; <span class="id" type="keyword">let</span> (<span class="id" type="var">s</span>, <span class="id" type="var">t</span>) := <span class="id" type="var">s_t</span> <span class="id" type="keyword">in</span> <span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t</span>)) <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">nil</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>); <span class="id" type="tactic">try</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">NatMul.LP.permut_refl</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>

<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">IHl1</span> <span class="id" type="var">l2</span> ((<span class="id" type="var">t1</span>,t2) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">list_size</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">combine</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">list_size_mul</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">size_ge_one</span> <span class="id" type="var">t1</span>) (<span class="id" type="var">size_ge_one</span> <span class="id" type="var">t2</span>).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">list_size_mul</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt; <span class="id" type="keyword">let</span> (<span class="id" type="var">s</span>, <span class="id" type="var">t</span>) := <span class="id" type="var">s_t</span> <span class="id" type="keyword">in</span> <span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">combine</span> <span class="id" type="var">term</span> ((<span class="id" type="var">t1</span>, <span class="id" type="var">t2</span>) :: <span class="id" type="var">l</span>) <span class="id" type="var">l1</span> <span class="id" type="var">l2</span>))<br/>
(<span class="id" type="var">list_size</span> <span class="id" type="var">size</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">list_size</span> <span class="id" type="var">size</span> <span class="id" type="var">l2</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t1</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t2</span>)<br/>
(<span class="id" type="var">list_size_mul</span> (<span class="id" type="var">term</span> * <span class="id" type="var">term</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">s_t</span> : <span class="id" type="var">term</span> * <span class="id" type="var">term</span> =&gt; <span class="id" type="keyword">let</span> (<span class="id" type="var">s</span>, <span class="id" type="var">t</span>) := <span class="id" type="var">s_t</span> <span class="id" type="keyword">in</span> <span class="id" type="var">max</span> (<span class="id" type="var">size</span> <span class="id" type="var">s</span>) (<span class="id" type="var">size</span> <span class="id" type="var">t</span>)) <span class="id" type="var">l</span>).<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">t1</span> <span class="id" type="var">l1</span> <span class="id" type="var">sigma</span> <span class="id" type="var">IHl1</span> <span class="id" type="var">t2</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">nl</span> <span class="id" type="var">nl1</span> <span class="id" type="var">nl2</span> <span class="id" type="var">nt1</span> <span class="id" type="var">nt2</span> <span class="id" type="var">n</span> <span class="id" type="var">H1</span> <span class="id" type="var">H2</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">refine</span> (@<span class="id" type="var">trans_clos_is_trans</span> <span class="id" type="var">_</span> (<span class="id" type="var">NatMul.multiset_extension_step</span> <span class="id" type="var">lt</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="var">left</span>;<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">NatMul.rmv_case</span> <span class="id" type="var">lt</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l1</span> := <span class="id" type="var">S</span> (<span class="id" type="var">max</span> <span class="id" type="var">nl1</span> <span class="id" type="var">nl2</span>) :: <span class="id" type="var">max</span> <span class="id" type="var">nt1</span> <span class="id" type="var">nt2</span> :: <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l2</span> := <span class="id" type="var">S</span> (<span class="id" type="var">max</span> (<span class="id" type="var">nt1</span> + <span class="id" type="var">nl1</span>) (<span class="id" type="var">nt2</span> + <span class="id" type="var">nl2</span>)) :: <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">l</span> := <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">S</span> (<span class="id" type="var">max</span> <span class="id" type="var">nl1</span> <span class="id" type="var">nl2</span>) :: <span class="id" type="var">max</span> <span class="id" type="var">nt1</span> <span class="id" type="var">nt2</span> :: <span class="id" type="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">a</span> := <span class="id" type="var">S</span> (<span class="id" type="var">max</span> (<span class="id" type="var">nt1</span> + <span class="id" type="var">nl1</span>) (<span class="id" type="var">nt2</span> + <span class="id" type="var">nl2</span>)))).<br/>
<span class="id" type="tactic">unfold</span>  <span class="id" type="var">NatMul.DS.eq_A</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> [<span class="id" type="var">b_eq</span> | [<span class="id" type="var">b_eq</span> | <span class="id" type="var">b_in_nil</span>]].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">b</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">max_case2</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">le_trans</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">le_max_l</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)); <span class="id" type="tactic">destruct</span> <span class="id" type="var">nt1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">nt1</span>].<br/>
<span class="id" type="tactic">inversion</span> <span class="id" type="var">H1</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_plus_r</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">le_trans</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">le_max_r</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)); <span class="id" type="tactic">destruct</span> <span class="id" type="var">nt2</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">nt2</span>].<br/>
<span class="id" type="tactic">inversion</span> <span class="id" type="var">H2</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_plus_r</span>.<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">b</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">max_case2</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">le_trans</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">le_max_l</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)); <span class="id" type="tactic">apply</span> <span class="id" type="var">le_plus_l</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">le_n_S</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">le_trans</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">le_max_r</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>)); <span class="id" type="tactic">apply</span> <span class="id" type="var">le_plus_l</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">inv_solved_part</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">pb</span>, <span class="id" type="var">Inv_solved_part</span> <span class="id" type="var">pb</span> -&gt; <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">decomposition_step</span> <span class="id" type="var">pb</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">Inv_solved_part</span> <span class="id" type="var">pb'</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">Inv_solved_part</span>, <span class="id" type="var">decomposition_step</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">sigma</span> [ | [<span class="id" type="var">s</span> <span class="id" type="var">t</span>] <span class="id" type="var">l</span>]] <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">T1.eq_bool_ok</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">T1.eq_bool</span>  <span class="id" type="var">s</span> <span class="id" type="var">t</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">s_diff_t</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">y</span> | ]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">H1</span> <span class="id" type="var">H2</span>]; <span class="id" type="tactic">split</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">assumption</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x</span> | <span class="id" type="var">f</span> <span class="id" type="var">l1</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y</span> | <span class="id" type="var">g</span> <span class="id" type="var">l2</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hx</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>];  <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hx</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hx</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Inv_pb_x</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">split</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_in_y_x_val'_l'</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_y_x_val'_l'</span> <span class="id" type="var">x_in_y_x_val'</span> <span class="id" type="var">x_in_l'</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_y_x_val'</span> <span class="id" type="var">x_in_y</span> <span class="id" type="var">x_in_x_val'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_y</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_nil</span>]; [<span class="id" type="tactic">trivial</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">solved_var_inc_not_mem</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_x_val'</span>); <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">solved_var_inc_not_mem_list</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_l'</span>); <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_in_y_sigma'</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_y_sigma'</span> <span class="id" type="var">x_in_y</span> <span class="id" type="var">x_in_sigma'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_y</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_nil</span>]; [<span class="id" type="tactic">trivial</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">solved_var_inc_not_mem_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_sigma'</span>); <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span>| <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span>]; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l'</span>]; <span class="id" type="tactic">simpl</span>; [<span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="keyword">match</span> (<span class="id" type="keyword">if</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span> <span class="id" type="keyword">then</span> <span class="id" type="var">Some</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="keyword">else</span> <span class="id" type="var">None</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">v_sigma</span> =&gt; <span class="id" type="var">v_sigma</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">Var</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> = <span class="id" type="var">Var</span> (<span class="id" type="keyword">if</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span> <span class="id" type="keyword">then</span> <span class="id" type="var">y</span> <span class="id" type="keyword">else</span> <span class="id" type="var">v</span>)).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_x_y_l</span> <span class="id" type="var">z_not_in_sigma</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">z</span>=x); <span class="id" type="tactic">assumption</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_y_x_val'_l'</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_x_val'_l'</span> <span class="id" type="var">z_in_y_x_val'</span> <span class="id" type="var">z_in_l'</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_x_val'</span> <span class="id" type="var">z_in_y</span> <span class="id" type="var">z_in_x_val'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>;<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hx</span> <span class="id" type="var">z_in_x_val'</span>).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_list</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_y_sigma</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_sigma</span> <span class="id" type="var">z_in_y</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">split</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_in_l'</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">solved_var_inc_not_mem_list</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_l'</span>); <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_in_y_sigma'</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_y_sigma'</span> <span class="id" type="var">x_in_y</span> <span class="id" type="var">x_in_sigma'</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_y</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_y</span> | <span class="id" type="var">x_in_nil</span>]; [<span class="id" type="tactic">trivial</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">solved_var_inc_not_mem_subst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_sigma'</span>); <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hz</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">z_sigma</span>];<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l'</span>]; <span class="id" type="tactic">simpl</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="keyword">match</span> (<span class="id" type="keyword">if</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span> <span class="id" type="keyword">then</span> <span class="id" type="var">Some</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="keyword">else</span> <span class="id" type="var">None</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">v_sigma</span> =&gt; <span class="id" type="var">v_sigma</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">Var</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> = <span class="id" type="var">Var</span> (<span class="id" type="keyword">if</span> <span class="id" type="var">eq_var_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span> <span class="id" type="keyword">then</span> <span class="id" type="var">y</span> <span class="id" type="keyword">else</span> <span class="id" type="var">v</span>)).<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_x_y_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hz</span>; <span class="id" type="tactic">split</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">z_diff_x</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_l'</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_list</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_y_sigma</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_sigma</span> <span class="id" type="var">z_in_y</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_y_l</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">x_val</span>)) <span class="id" type="keyword">as</span> [ <span class="id" type="var">L</span> | <span class="id" type="var">L</span> ].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l'</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">find</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_eq_z</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">z</span> =x); <span class="id" type="tactic">assumption</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_x_t2_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <br/>
<span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_x_val_t2_l</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_t2_sigma</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2_l</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_x_val</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_t2_l</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span> <span class="id" type="keyword">in</span> *; <br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_t2_l</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t2_sigma</span> <span class="id" type="var">z_in_t2</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_t2_l</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span> <span class="id" type="keyword">in</span> *; <br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l'</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_x_t2_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <br/>
<span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_x_val_t2_l</span> | <span class="id" type="tactic">assumption</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2_l</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_x_val_t2</span> <span class="id" type="var">z_in_x_val</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_t2_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_t2_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_x</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l'</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">find</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">z</span> =x); <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_x_t2_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <br/>
<span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_x_val_t2_l</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_t2_sigma</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_t2_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t2_sigma</span> <span class="id" type="var">z_in_t2</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_x_t2_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">assumption</span>.<br/>

<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">y_val</span> <span class="id" type="var">y_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_sigma</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">y_val</span>)) <span class="id" type="keyword">as</span> [ <span class="id" type="var">L</span> | <span class="id" type="var">L</span> ].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">g</span> <span class="id" type="var">l'</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">find</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">z</span> =y); <span class="id" type="tactic">assumption</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_y_t1_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <br/>
<span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_y_val_t1_l</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_t1_sigma</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_val_t1_l</span> <span class="id" type="var">z_in_y_val_t1</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_val_t1</span> <span class="id" type="var">z_in_y_val</span> <span class="id" type="var">z_in_t1</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">y</span> <span class="id" type="var">y_val</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_y_t1_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_y_t1_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t1_sigma</span> <span class="id" type="var">z_in_t1</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_y_t1_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">g</span> <span class="id" type="var">l'</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_y_t1_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <br/>
<span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_y_val_t1_l</span> | <span class="id" type="tactic">assumption</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_val_t1_l</span> <span class="id" type="var">z_in_y_val_t1</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_y_val_t1</span> <span class="id" type="var">z_in_y_val</span> <span class="id" type="var">z_in_t1</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">solved_var_inc_occ_in_subst</span> <span class="id" type="keyword">with</span> <span class="id" type="var">y</span> <span class="id" type="var">y_val</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_y_t1_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_y_t1_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_y</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">g</span> <span class="id" type="var">l'</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">find</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">z_eq_y</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">z</span> =y); <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_y_t1_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <br/>
<span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_y_val_t1_l</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_t1_sigma</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_y_t1_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t1_sigma</span> <span class="id" type="var">z_in_t1</span> <span class="id" type="var">z_in_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_y_t1_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_sigma</span>; <span class="id" type="tactic">assumption</span>.<br/>

<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">F.Symb.eq_bool_ok</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">F.Symb.eq_bool</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">f_eq_g</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">g</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">intro</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [ <span class="id" type="tactic">intros</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z_sigma</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">z_val</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">v</span> | <span class="id" type="var">h</span> <span class="id" type="var">l'</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">z_not_in_t1_t2_l</span> <span class="id" type="var">z_not_in_sigma</span>]; <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_l1_l2_l</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">z_not_in_t1_t2_l</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">z_sigma</span> <span class="id" type="var">z_not_in_t1_t2_l</span> <span class="id" type="var">z_not_in_sigma</span> <span class="id" type="var">s_diff_t</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">L</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">l2</span> <span class="id" type="var">l</span> <span class="id" type="var">z_in_l1_l2_l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l1</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">t1</span> <span class="id" type="var">l1</span>]; <span class="id" type="tactic">intros</span> [ | <span class="id" type="var">t2</span> <span class="id" type="var">l2</span>] <span class="id" type="var">l</span> <span class="id" type="var">z_in_l1_l2_l</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">IHl1</span> <span class="id" type="var">l2</span> ((<span class="id" type="var">t1</span>,t2) :: <span class="id" type="var">l</span>) <span class="id" type="var">z_in_l1_l2_l</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">z_in_l1_l2_l</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_l1_l2_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l1_l2_l</span> <span class="id" type="var">z_in_t1_t2</span> <span class="id" type="var">z_in_l1_l2_l'</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_t1_t2</span> <span class="id" type="var">z_in_t1</span> <span class="id" type="var">z_in_t2</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l1_l2_l'</span> <span class="id" type="var">z_in_l1_l2</span> <span class="id" type="var">z_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">z_in_l1_l2</span> <span class="id" type="var">z_in_l1</span> <span class="id" type="var">z_in_l2</span>.<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">solved_var_swapp_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>, <span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">x</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>,t) :: <span class="id" type="var">l</span>)) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">x</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">t</span>,s) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">is_a_solved_var</span> <span class="id" type="var">x</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>, <span class="id" type="var">t</span>) :: <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_solved</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_solved</span>; <span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">x_solved</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_not_in_s_t_l</span> <span class="id" type="var">x_not_in_sigma</span>]; <span class="id" type="tactic">split</span>; [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_in_t_s_l</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">x_not_in_s_t_l</span>; <span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_t_s_l</span> <span class="id" type="var">x_in_t_s</span> <span class="id" type="var">x_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_t_s</span> <span class="id" type="var">x_in_t</span> <span class="id" type="var">x_in_s</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_not_solved</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_not_solved</span>; <span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">not_solved_var</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">x_not_solved</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_in_s_t_l</span> | <span class="id" type="var">x_in_sigma</span>]; [<span class="id" type="var">left</span> | <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_s_t_l</span> <span class="id" type="var">x_in_s_t</span> <span class="id" type="var">x_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span> <span class="id" type="var">x_in_s_t</span> <span class="id" type="var">x_in_s</span> <span class="id" type="var">x_in_t</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">measure_for_unif_pb_swapp_eq</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">measure_for_unif_pb</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>,t) :: <span class="id" type="var">l</span>)) = <span class="id" type="var">measure_for_unif_pb</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">t</span>,s) :: <span class="id" type="var">l</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Phi1</span> : <span class="id" type="var">phi1</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>,t) :: <span class="id" type="var">l</span>)) = <span class="id" type="var">phi1</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">t</span>,s) :: <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.cardinal_eq_set</span>; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.subset_filter</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">v_in_s_t_l_sigma</span>; <span class="id" type="var">destruct_set</span>  <span class="id" type="var">v_in_s_t_l_sigma</span> <span class="id" type="var">v_in_s_t_l</span> <span class="id" type="var">v_in_sigma</span>.<br/>
<span class="id" type="var">destruct_set</span>  <span class="id" type="var">v_in_s_t_l</span> <span class="id" type="var">v_in_s_t</span> <span class="id" type="var">v_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span>  <span class="id" type="var">v_in_s_t</span> <span class="id" type="var">v_in_s</span> <span class="id" type="var">v_in_t</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var_swapp_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">v_in_s_t_l_sigma</span>; <span class="id" type="var">destruct_set</span>  <span class="id" type="var">v_in_s_t_l_sigma</span> <span class="id" type="var">v_in_s_t_l</span> <span class="id" type="var">v_in_sigma</span>.<br/>
<span class="id" type="var">destruct_set</span>  <span class="id" type="var">v_in_s_t_l</span> <span class="id" type="var">v_in_s_t</span> <span class="id" type="var">v_in_l</span>.<br/>
<span class="id" type="var">destruct_set</span>  <span class="id" type="var">v_in_s_t</span> <span class="id" type="var">v_in_s</span> <span class="id" type="var">v_in_t</span>.<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">do</span> 3 <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var_swapp_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Phi2</span> : <span class="id" type="var">phi2</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>,t) :: <span class="id" type="var">l</span>)) = <span class="id" type="var">phi2</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">t</span>,s) :: <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi2</span>, <span class="id" type="var">size_of_solved_part</span>, <span class="id" type="var">size_of_unsolved_part</span>; <span class="id" type="tactic">simpl</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">max_comm</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Phi3</span> : <span class="id" type="var">phi3</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">s</span>,t) :: <span class="id" type="var">l</span>)) = <span class="id" type="var">phi3</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> ((<span class="id" type="var">t</span>,s) :: <span class="id" type="var">l</span>))).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">phi3</span>, <span class="id" type="var">nb_var_eq_of_unsolved_part</span>; <span class="id" type="tactic">simpl</span>;<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">measure_for_unif_pb</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Phi1</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Phi2</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Phi3</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_step_decreases</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">pb</span>, <span class="id" type="var">Inv_solved_part</span> <span class="id" type="var">pb</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">decomposition_step</span> <span class="id" type="var">pb</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">lt_pb</span> <span class="id" type="var">pb'</span> <span class="id" type="var">pb</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">sigma</span> [ | [<span class="id" type="var">s</span> <span class="id" type="var">t</span>] <span class="id" type="var">l</span>]] <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">decomposition_step</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">unsolved_part</span>; <span class="id" type="var">cbv</span> <span class="id" type="var">iota</span> <span class="id" type="var">beta</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">T1.eq_bool_ok</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">T1.eq_bool</span> <span class="id" type="var">s</span> <span class="id" type="var">t</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">s_eq_t</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">s_diff_t</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">s</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">remove_trivial_eq_decreases</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">x</span> | <span class="id" type="var">f</span> <span class="id" type="var">l1</span> ]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [ <span class="id" type="var">y</span> | <span class="id" type="var">g</span> <span class="id" type="var">l2</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hx</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span> ];<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hx</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hx</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">coalesce1_decreases</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">coalesce2_decreases</span>; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">s_diff_t</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_val</span> <span class="id" type="var">x_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span> ].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">l2</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">x_val</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">t2_lt_x_val</span> | <span class="id" type="var">t2_ge_x_val</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">merge1_decreases</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">merge2_decreases</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">move_eq_decreases</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">y_val</span> <span class="id" type="var">y_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_sigma</span> ].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">y_val</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">t1_lt_y_val</span> | <span class="id" type="var">t1_ge_y_val</span>].<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">measure_for_unif_pb_swapp_eq</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>));<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">merge1_decreases</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">measure_for_unif_pb_swapp_eq</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>));<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">merge2_decreases</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">Inv_solved_part</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">Inv_pb</span> <span class="id" type="var">x</span>).<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [[<span class="id" type="var">v</span> | <span class="id" type="var">f'</span> <span class="id" type="var">l'</span>] | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">solved_var_swapp_eq</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_pb</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">measure_for_unif_pb_swapp_eq</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l1</span>));<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">move_eq_decreases</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">F.Symb.eq_bool_ok</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">F.Symb.eq_bool</span> <span class="id" type="var">f</span> <span class="id" type="var">g</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">f_eq_g</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">g</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">intro</span> <span class="id" type="var">L</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">solved_part</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">decomposition_decreases</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab116"></a><h3 class="section">Definition of a step of decomposition for the loop.</h3>

</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Inv_solved_part_e</span> <span class="id" type="var">e</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">pb</span> =&gt; <span class="id" type="var">Inv_solved_part</span> <span class="id" type="var">pb</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> <span class="id" type="var">pb</span> =&gt; <span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>) = <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">exc_pb_ok</span> : <span class="id" type="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">OK</span> : <span class="id" type="keyword">forall</span> (<span class="id" type="var">e</span> : <span class="id" type="var">exc</span> <span class="id" type="var">unification_problem</span>), <span class="id" type="var">Inv_solved_part_e</span> <span class="id" type="var">e</span> -&gt; <span class="id" type="var">exc_pb_ok</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">weight_exc_pb_ok</span>  <span class="id" type="var">e</span> := <br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">OK</span> (<span class="id" type="var">Normal</span> <span class="id" type="var">pb</span>)  <span class="id" type="var">_</span>  =&gt; (2, <span class="id" type="var">measure_for_unif_pb</span> <span class="id" type="var">pb</span>)<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">OK</span> (<span class="id" type="var">Not_appliable</span> <span class="id" type="var">pb</span>) <span class="id" type="var">_</span>  =&gt; (1, <span class="id" type="var">measure_for_unif_pb</span> <span class="id" type="var">pb</span>)<br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">OK</span> <span class="id" type="var">No_solution</span>  <span class="id" type="var">_</span> =&gt; (0, (0,(nil,0)))<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt_weight_exc_pb_ok</span> (<span class="id" type="var">w1</span> <span class="id" type="var">w2</span> : <span class="id" type="var">nat</span> * (<span class="id" type="var">nat</span> * (<span class="id" type="var">list</span> <span class="id" type="var">nat</span> * <span class="id" type="var">nat</span>))) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">w1</span>, <span class="id" type="var">w2</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">n1</span>,m1), (<span class="id" type="var">n2</span>,m2) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">beq_nat</span> <span class="id" type="var">n1</span> <span class="id" type="var">n2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <span class="id" type="var">lt_ms</span> <span class="id" type="var">m1</span> <span class="id" type="var">m2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">n1</span> &lt; <span class="id" type="var">n2</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lt_exc_pb_ok</span> (<span class="id" type="var">u1</span> <span class="id" type="var">u2</span> : <span class="id" type="var">exc_pb_ok</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">lt_weight_exc_pb_ok</span> (<span class="id" type="var">weight_exc_pb_ok</span> <span class="id" type="var">u1</span>) (<span class="id" type="var">weight_exc_pb_ok</span> <span class="id" type="var">u2</span>).<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">wf_lt_exc_pb_ok</span> : <span class="id" type="var">well_founded</span> <span class="id" type="var">lt_exc_pb_ok</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">wf_inverse_image</span> (<span class="id" type="var">exc_pb_ok</span>) <span class="id" type="var">_</span> <span class="id" type="var">lt_weight_exc_pb_ok</span> <span class="id" type="var">weight_exc_pb_ok</span>).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">well_founded</span>, <span class="id" type="var">lt_weight_exc_pb_ok</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">n</span> <span class="id" type="var">m</span>]; <span class="id" type="tactic">generalize</span> <span class="id" type="var">m</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">m</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">well_founded_ind</span> <span class="id" type="var">lt_wf</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">n</span>).<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">n</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">IHn</span> <span class="id" type="var">m</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Acc_intro</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">n'</span> <span class="id" type="var">m'</span>]; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> <span class="id" type="var">n'</span> <span class="id" type="var">n</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n'</span> <span class="id" type="var">n</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">n'_eq_n</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">n'</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">n'_diff_n</span>].<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">m'</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">m</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">well_founded_ind</span> <span class="id" type="var">wf_lt_ms</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">m</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">m</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">m</span> <span class="id" type="var">IHm</span> <span class="id" type="var">m'</span> <span class="id" type="var">m'_lt_m</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Acc_intro</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">n''</span> <span class="id" type="var">m''</span>]; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> <span class="id" type="var">n''</span> <span class="id" type="var">n</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> <span class="id" type="var">n''</span> <span class="id" type="var">n</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">n''_eq_n</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">n''_diff_n</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">n''</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHm</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">n''_lt_n</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHn</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">n'_lt_n</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHn</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">inv_solved_part_e</span> : <br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">pb</span>, <span class="id" type="var">Inv_solved_part</span> <span class="id" type="var">pb</span> \/ <span class="id" type="var">pb</span>.(<span class="id" type="var">unsolved_part</span>) = <span class="id" type="var">nil</span> -&gt; <span class="id" type="var">Inv_solved_part_e</span> (<span class="id" type="var">decomposition_step</span> <span class="id" type="var">pb</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">sigma</span> [ | [<span class="id" type="var">s</span> <span class="id" type="var">t</span>] <span class="id" type="var">l</span>]] [<span class="id" type="var">Inv_pb</span> | <span class="id" type="var">l_eq_nil</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">inv_solved_part</span> <span class="id" type="var">_</span> <span class="id" type="var">Inv_pb</span>); <span class="id" type="tactic">unfold</span> <span class="id" type="var">decomposition_step</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">T1.eq_bool</span>  <span class="id" type="var">s</span> <span class="id" type="var">t</span>).<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">s</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x</span> | <span class="id" type="var">f1</span> <span class="id" type="var">l1</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y</span> | <span class="id" type="var">f2</span> <span class="id" type="var">l2</span>].<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">v_sigma</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">y</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_sigma</span>) <span class="id" type="var">sigma</span>)); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">case</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f2</span> <span class="id" type="var">l2</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">x_val</span>)); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">y_val</span>; <span class="id" type="tactic">case</span> (<span class="id" type="var">lt_ge_dec</span> (<span class="id" type="var">T.size</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f1</span> <span class="id" type="var">l1</span>)) (<span class="id" type="var">T.size</span> <span class="id" type="var">y_val</span>)); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">F.Symb.eq_bool</span> <span class="id" type="var">f1</span> <span class="id" type="var">f2</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> (<span class="id" type="var">length</span> <span class="id" type="var">l1</span>) (<span class="id" type="var">length</span> <span class="id" type="var">l2</span>)); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">decomposition_step_e</span> (<span class="id" type="var">e</span> : <span class="id" type="var">exc_pb_ok</span>) : <span class="id" type="var">exc_pb_ok</span>.<br/>
<span class="id" type="tactic">intros</span> [ [ <span class="id" type="var">pb</span> | <span class="id" type="var">pb</span> | ]  <span class="id" type="var">Inv_pb</span> ].<br/>
<span class="id" type="tactic">exact</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">decomposition_step</span> <span class="id" type="var">pb</span>) (<span class="id" type="var">inv_solved_part_e</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> <span class="id" type="var">Inv_pb</span>))).<br/>
<span class="id" type="tactic">exact</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">Not_appliable</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span>) <span class="id" type="var">Inv_pb</span>).<br/>
<span class="id" type="tactic">exact</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">No_solution</span> <span class="id" type="var">_</span>) <span class="id" type="var">Inv_pb</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_e_unfold_not_app</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">pb</span> <span class="id" type="var">Inv_pb</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">decomposition_step_e</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">Not_appliable</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span>) <span class="id" type="var">Inv_pb</span>) = <span class="id" type="var">OK</span> (<span class="id" type="var">Not_appliable</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span>) <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_e_unfold_no_sol</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">Inv_pb</span>,<br/>
&nbsp;&nbsp;<span class="id" type="var">decomposition_step_e</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">No_solution</span> <span class="id" type="var">_</span>) <span class="id" type="var">Inv_pb</span>) = <span class="id" type="var">OK</span> (<span class="id" type="var">No_solution</span> <span class="id" type="var">_</span>) <span class="id" type="var">Inv_pb</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_e_unfold_normal</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">pb</span> <span class="id" type="var">Inv_pb</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">decomposition_step_e</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">Normal</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span>) <span class="id" type="var">Inv_pb</span>) = <br/>
&nbsp;<span class="id" type="var">OK</span> (<span class="id" type="var">decomposition_step</span> <span class="id" type="var">pb</span>) (<span class="id" type="var">inv_solved_part_e</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> <span class="id" type="var">Inv_pb</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">pb</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decomposition_step_decreases_e</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">pb</span> (<span class="id" type="var">Inv_pb</span> : <span class="id" type="var">Inv_solved_part</span> <span class="id" type="var">pb</span>),<br/>
&nbsp;&nbsp;<span class="id" type="var">lt_exc_pb_ok</span> (<span class="id" type="var">decomposition_step_e</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">Normal</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span>) <span class="id" type="var">Inv_pb</span>)) (<span class="id" type="var">OK</span> (<span class="id" type="var">Normal</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span>) <span class="id" type="var">Inv_pb</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">pb</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">decomposition_e_unfold_normal</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">lt_exc_pb_ok</span>, <span class="id" type="var">lt_weight_exc_pb_ok</span>, <span class="id" type="var">lt_pb</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">decomposition_step_decreases</span> <span class="id" type="var">pb</span> <span class="id" type="var">Inv_pb</span>).<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">decomposition_step</span> <span class="id" type="var">pb</span>).<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> 1 2); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> 1 2); [<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">beq_nat_ok</span> 0 2); <span class="id" type="tactic">case</span> (<span class="id" type="var">beq_nat</span> 0 2); [<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">auto</span> <span class="id" type="keyword">with</span> <span class="id" type="var">arith</span>].<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">F_decompose</span> : <br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">u</span> : <span class="id" type="var">exc_pb_ok</span>),<br/>
&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">u'</span> : <span class="id" type="var">exc_pb_ok</span> , <span class="id" type="var">lt_exc_pb_ok</span> <span class="id" type="var">u'</span> <span class="id" type="var">u</span> -&gt; <span class="id" type="var">exc</span> <span class="id" type="var">unification_problem</span>) -&gt; <br/>
&nbsp;<span class="id" type="var">exc</span> <span class="id" type="var">unification_problem</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> [[<span class="id" type="var">pb</span> | <span class="id" type="var">pb</span> | ] <span class="id" type="var">Inv_pb</span>] <span class="id" type="var">IH</span>.<br/>
<span class="id" type="tactic">exact</span> (<span class="id" type="var">IH</span> <span class="id" type="var">_</span> (<span class="id" type="var">decomposition_step_decreases_e</span> <span class="id" type="var">pb</span> <span class="id" type="var">Inv_pb</span>)).<br/>
<span class="id" type="tactic">exact</span> (<span class="id" type="var">Not_appliable</span> <span class="id" type="var">_</span> <span class="id" type="var">pb</span>).<br/>
<span class="id" type="tactic">exact</span> (<span class="id" type="var">No_solution</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">decompose</span> :  <span class="id" type="keyword">forall</span> (<span class="id" type="var">u</span> : <span class="id" type="var">exc_pb_ok</span>),  (<span class="id" type="var">exc</span> <span class="id" type="var">unification_problem</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span>; <span class="id" type="tactic">exact</span> (<span class="id" type="keyword">Fix</span> <span class="id" type="var">wf_lt_exc_pb_ok</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">exc</span> <span class="id" type="var">unification_problem</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">F_decompose</span> <span class="id" type="var">u</span>).<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decompose_unfold</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">u</span> : <span class="id" type="var">exc_pb_ok</span>,<br/>
<span class="id" type="var">decompose</span> <span class="id" type="var">u</span> = @<span class="id" type="var">F_decompose</span> <span class="id" type="var">u</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">u'</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">decompose</span> <span class="id" type="var">u'</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">decompose</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">Fix_eq</span> <span class="id" type="keyword">with</span> (<span class="id" type="var">P</span>:= (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span>: <span class="id" type="var">exc_pb_ok</span> =&gt; <span class="id" type="var">exc</span> <span class="id" type="var">unification_problem</span>)); <span class="id" type="tactic">clear</span> <span class="id" type="var">u</span>.<br/>
<span class="id" type="tactic">intros</span> [ [<span class="id" type="var">pb</span> | <span class="id" type="var">pb</span> | ] <span class="id" type="var">Inv_pb</span>] <span class="id" type="var">f</span> <span class="id" type="var">g</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span>; [ <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span> | <span class="id" type="var">idtac</span> | <span class="id" type="var">idtac</span> ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decompose_nf</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">e</span>,<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">decompose</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>) =&gt; <span class="id" type="var">l</span> = <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">e</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">e</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">well_founded_ind</span> <span class="id" type="var">wf_lt_exc_pb_ok</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">e</span>.<br/>
<span class="id" type="tactic">intros</span> [ [<span class="id" type="var">pb</span> | <span class="id" type="var">pb</span> | ] <span class="id" type="var">Inv_pb</span>] <span class="id" type="var">IH</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">decompose_unfold</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">decomposition_step_decreases_e</span> <span class="id" type="var">_</span> <span class="id" type="var">Inv_pb</span>).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Inv_pb</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">pb</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">is_a_solution_e</span> <span class="id" type="var">e</span> <span class="id" type="var">sigma</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">OK</span> (<span class="id" type="var">Normal</span> <span class="id" type="var">pb</span>) <span class="id" type="var">_</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb</span> <span class="id" type="var">sigma</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">OK</span> (<span class="id" type="var">Not_appliable</span> <span class="id" type="var">pb</span>) <span class="id" type="var">_</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb</span> <span class="id" type="var">sigma</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">OK</span> <span class="id" type="var">No_solution</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decompose_is_sound</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">e</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">decompose</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb'</span> <span class="id" type="var">sigma</span> -&gt; <span class="id" type="var">is_a_solution_e</span> <span class="id" type="var">e</span> <span class="id" type="var">sigma</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">e</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">e</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">well_founded_ind</span> <span class="id" type="var">wf_lt_exc_pb_ok</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">e</span>.<br/>
<span class="id" type="tactic">intros</span> [[<span class="id" type="var">pb</span> | <span class="id" type="var">pb</span> | ] <span class="id" type="var">Inv_pb</span>] <span class="id" type="var">IH</span> <span class="id" type="var">theta</span>; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">decompose_unfold</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">F_decompose</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">IH</span> <span class="id" type="var">_</span> (<span class="id" type="var">decomposition_step_decreases_e</span> <span class="id" type="var">_</span> <span class="id" type="var">Inv_pb</span>) <span class="id" type="var">theta</span>).<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">pb</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">sigma</span> <span class="id" type="var">l</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">decompose</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">decomposition_step_e</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">Normal</span> <span class="id" type="var">unification_problem</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>)) <span class="id" type="var">Inv_pb</span>))).<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma_is_sol</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">H'</span> := <span class="id" type="var">H</span> <span class="id" type="var">sigma_is_sol</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H''</span> := <span class="id" type="var">decomposition_step_is_sound</span> <span class="id" type="var">l</span> <span class="id" type="var">sigma</span> <span class="id" type="var">theta</span>).<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">decomposition_step</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>)); <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">H''</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">H''</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">decompose_is_complete</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">e</span> <span class="id" type="var">sigma</span>, <span class="id" type="var">is_a_solution_e</span> <span class="id" type="var">e</span> <span class="id" type="var">sigma</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">decompose</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Normal</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Not_appliable</span> <span class="id" type="var">pb'</span> =&gt; <span class="id" type="var">is_a_solution</span> <span class="id" type="var">pb'</span> <span class="id" type="var">sigma</span>  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">No_solution</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">e</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">e</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">well_founded_ind</span> <span class="id" type="var">wf_lt_exc_pb_ok</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">e</span>.<br/>
<span class="id" type="tactic">intros</span> [[<span class="id" type="var">pb</span> | <span class="id" type="var">pb</span> | ] <span class="id" type="var">Inv_pb</span>] <span class="id" type="var">IH</span> <span class="id" type="var">theta</span> <span class="id" type="var">theta_is_sol</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">decompose_unfold</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">F_decompose</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">IH</span> <span class="id" type="var">_</span> (<span class="id" type="var">decomposition_step_decreases_e</span> <span class="id" type="var">_</span> <span class="id" type="var">Inv_pb</span>) <span class="id" type="var">theta</span>).<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">pb</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">sigma</span> <span class="id" type="var">l</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">decompose</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">decomposition_step_e</span> (<span class="id" type="var">OK</span> (<span class="id" type="var">Normal</span> <span class="id" type="var">unification_problem</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">l</span>)) <span class="id" type="var">Inv_pb</span>)));<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">theta_is_sol</span>;<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">decomposition_step_is_complete</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">inv_solved_part_init</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span>, <span class="id" type="var">Inv_solved_part</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">nil</span> ((<span class="id" type="var">t1</span>, <span class="id" type="var">t2</span>) :: <span class="id" type="var">nil</span>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">Inv_solved_part</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">rep_var_is_complete</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">sigma'</span> := (<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">xt</span> =&gt; (<span class="id" type="var">fst</span> <span class="id" type="var">xt</span>, <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <span class="id" type="var">nil</span>) (<span class="id" type="var">snd</span> <span class="id" type="var">xt</span>))) <span class="id" type="var">sigma</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">tau</span>, <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">nil</span>) <span class="id" type="var">tau</span> &lt;-&gt; <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma'</span> <span class="id" type="var">nil</span>) <span class="id" type="var">tau</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> <span class="id" type="var">sigma'</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">sigma'</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">as</span> [ | [<span class="id" type="var">y</span> <span class="id" type="var">y_val</span>] <span class="id" type="var">sigma</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">tau</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">is_a_solution</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">v</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">reflexivity</span> | <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">_</span> <span class="id" type="var">Hsol</span>]; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hsol_x</span> := <span class="id" type="var">Hsol</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsol_x</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">Hsol_v</span> := <span class="id" type="var">Hsol</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsol_v</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map</span> <span class="id" type="var">X.eq_bool</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">y</span>,y_val) :: <span class="id" type="var">sigma</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>))) :: <span class="id" type="var">nil</span>)) <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="var">revert</span> <span class="id" type="var">F</span> <span class="id" type="var">Hsol_x</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_y</span>].<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">Hsol_v</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">v_val</span> | ]; <span class="id" type="tactic">intros</span> <span class="id" type="var">Hsol_v</span> <span class="id" type="var">F</span> <span class="id" type="var">Hsol_x</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_v</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_v_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">Hsol_v</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_eq_y</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>); <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">Hsol_v</span>;<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_y</span>];<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">Hsol_v</span> <span class="id" type="var">F</span> <span class="id" type="var">Hsol_x</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_v</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> <span class="id" type="var">v_in_y_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">v_val</span> | ]; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_v</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_y_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">_</span> <span class="id" type="var">Hsol</span>]; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsol</span> <span class="id" type="var">x</span>) (<span class="id" type="var">Hsol</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">Hsol</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">find_map</span> <span class="id" type="var">X.eq_bool</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">y</span>,y_val) :: <span class="id" type="var">sigma</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>))) :: <span class="id" type="var">nil</span>)) <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">y</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">x_diff_y</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">v_val</span> <span class="id" type="var">v_sigma</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">Hsol_v</span> <span class="id" type="var">Hsol_x</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_v</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_v_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_x</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">y</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_y</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_y</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">y</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">y_eq_x</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>); <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_diff_x</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">F</span> <span class="id" type="var">Hsol_x</span> <span class="id" type="var">Hsol_v</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_v</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_y_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_x</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>];<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">F</span> <span class="id" type="var">Hsol_x</span> <span class="id" type="var">Hsol_v</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_v</span>; <span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">x_val</span> | ]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">v_val</span> | ]; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsol_v</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_v</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_v_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsol_x</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">is_a_cycle</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">c</span> : <span class="id" type="var">bool</span> :=<br/>
<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
| <span class="id" type="var">nil</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">current</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">current_val</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">src</span> <span class="id" type="var">current_val</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
| <span class="id" type="var">next</span> :: <span class="id" type="var">c'</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">current</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) =&gt; <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">current_val</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">var_in_term</span> <span class="id" type="var">next</span> <span class="id" type="var">current_val</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <span class="id" type="var">is_a_cycle</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span> <span class="id" type="var">c'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">is_a_cycle_all_var_inst</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span>, <span class="id" type="var">is_a_cycle</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, <span class="id" type="var">In</span> <span class="id" type="var">x</span> (<span class="id" type="var">current</span> :: <span class="id" type="var">c</span>) -&gt; <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">Term</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) =&gt; <span class="id" type="var">True</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> =&gt; <span class="id" type="var">False</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">In</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">Hcycle</span> <span class="id" type="var">x</span> [<span class="id" type="var">x_eq_current</span> | <span class="id" type="var">x_in_c</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">current</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [[ | ] | ]; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">current</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [[ | ] | ]; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">next</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">current</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [[ <span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l</span>] | ]; <span class="id" type="tactic">try</span> <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">next</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">discriminate</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_c</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_c</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_next</span> | <span class="id" type="var">x_in_c</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">next</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [[<span class="id" type="var">v</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>] | ]; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">next</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [[<span class="id" type="var">v</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>] | ]; <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">x_in_c</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span> <span class="id" type="var">Hcycle</span>).<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">is_a_cycle_discard</span> :<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span>,<br/>
&nbsp;&nbsp;~In <span class="id" type="var">x</span> (<span class="id" type="var">current</span> :: <span class="id" type="var">c</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_cycle</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">c</span> = <br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_cycle</span> ((<span class="id" type="var">x</span>,x_val) :: <span class="id" type="var">sigma</span>) <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">c</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">next</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">current</span> <span class="id" type="var">W</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">current</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">current</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">current_eq_x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">W</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span>).<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">current</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">current</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">current_eq_x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">W</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_in_next_c</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">W</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">oc_applies</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">VSet.without_red</span> (<span class="id" type="var">src</span> :: <span class="id" type="var">c</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_cycle</span> <span class="id" type="var">sigma</span> <span class="id" type="var">src</span> <span class="id" type="var">src</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt; <br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">tau</span>, <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">nil</span>) <span class="id" type="var">tau</span> -&gt; <span class="id" type="var">False</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">next</span> <span class="id" type="var">c</span>].<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span> <span class="id" type="var">W</span> <span class="id" type="var">Hcycle</span> <span class="id" type="var">tau</span> [<span class="id" type="var">_</span> <span class="id" type="var">Hsol</span>]; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsol</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">Hsol</span> <span class="id" type="var">src</span>); <span class="id" type="var">revert</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> [<span class="id" type="var">x</span> | <span class="id" type="var">f</span> <span class="id" type="var">l</span>] | <span class="id" type="tactic">intro</span> <span class="id" type="var">src_sol</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="var">idtac</span> | <span class="id" type="tactic">discriminate</span>].<br/>
<span class="id" type="tactic">intro</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_is_sound</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">src_in_l</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">var_in_subterm2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">in_impl_mem</span> (@<span class="id" type="var">eq</span> <span class="id" type="var">_</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> =&gt; <span class="id" type="var">refl_equal</span> <span class="id" type="var">a</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">src_in_l</span>)); <span class="id" type="tactic">intros</span> [ | <span class="id" type="var">i</span> <span class="id" type="var">p</span>] <span class="id" type="var">Hsubterm</span>.<br/>
<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hsubterm</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hsubterm'</span> := <span class="id" type="var">subterm_at_pos_apply_subst_apply_subst_subterm_at_pos</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>) (<span class="id" type="var">i</span> :: <span class="id" type="var">p</span>) <span class="id" type="var">tau</span>).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsubterm</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsubterm'</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hsize</span> := <span class="id" type="var">size_subterm_at_pos</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">tau</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)) <span class="id" type="var">i</span> <span class="id" type="var">p</span>).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsubterm'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsize</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">src_sol</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="var">apply_subst</span> <span class="id" type="tactic">at</span> 1 <span class="id" type="keyword">in</span> <span class="id" type="var">Hsize</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">src_sol</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsize</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">lt_irrefl</span> <span class="id" type="var">_</span> <span class="id" type="var">Hsize</span>).<br/>

<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span> <span class="id" type="var">W</span> <span class="id" type="var">Hcycle</span> <span class="id" type="var">tau</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">rep_var_is_complete</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">next</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.without_red_remove</span> <span class="id" type="var">src</span> <span class="id" type="var">nil</span> (<span class="id" type="var">next</span> :: <span class="id" type="var">c</span>) <span class="id" type="var">W</span>).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">is_a_cycle_discard</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">IHc</span> <span class="id" type="var">tau</span>; <span class="id" type="var">revert</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span> <span class="id" type="var">W</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span> : <span class="id" type="var">DecVar.A</span>,<br/>
<span class="id" type="var">VSet.without_red</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">next</span> :: <span class="id" type="var">c</span>) -&gt;<br/>
<span class="id" type="var">var_in_term</span> <span class="id" type="var">y</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) = <span class="id" type="var">true</span> -&gt;<br/>
<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
| <span class="id" type="var">Some</span> (<span class="id" type="var">Var</span> <span class="id" type="var">_</span>) =&gt; <span class="id" type="var">False</span><br/>
| <span class="id" type="var">Some</span> (<span class="id" type="var">Term</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) =&gt; <span class="id" type="var">True</span><br/>
| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">False</span><br/>
<span class="id" type="keyword">end</span> -&gt;<br/>
<span class="id" type="var">is_a_cycle</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x</span> <span class="id" type="var">src</span> (<span class="id" type="var">next</span> :: <span class="id" type="var">c</span>) = <span class="id" type="var">true</span> -&gt;<br/>
<span class="id" type="var">is_a_cycle</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">map</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">xt</span> : <span class="id" type="var">variable</span> * <span class="id" type="var">term</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">fst</span> <span class="id" type="var">xt</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <span class="id" type="var">nil</span>) (<span class="id" type="var">snd</span> <span class="id" type="var">xt</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sigma</span>) <span class="id" type="var">y</span> <span class="id" type="var">next</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">next'</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span> <span class="id" type="var">W</span> <span class="id" type="var">y_in_x_sigma</span> <span class="id" type="var">Hx</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l</span>] | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">src_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">src_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="var">idtac</span> | <span class="id" type="tactic">discriminate</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">next</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); [<span class="id" type="tactic">intro</span> <span class="id" type="var">next_in_l</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">next_not_in_l</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_in_l</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map</span> <span class="id" type="var">X.eq_bool</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <span class="id" type="var">nil</span>)) <span class="id" type="var">next</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">next</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> [<span class="id" type="var">v</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>] | <span class="id" type="var">idtac</span>];<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">next_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="var">idtac</span> | <span class="id" type="tactic">discriminate</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.A</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">simpl</span> <span class="id" type="var">apply_subst</span> <span class="id" type="tactic">at</span> 1 <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">apply_subst</span> <span class="id" type="tactic">at</span> 1; <span class="id" type="var">cbv</span> <span class="id" type="var">iota</span> <span class="id" type="var">beta</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">var_in_subterm2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">in_impl_mem</span> (@<span class="id" type="var">eq</span> <span class="id" type="var">_</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> =&gt; <span class="id" type="var">refl_equal</span> <span class="id" type="var">a</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hcycle</span>)); <span class="id" type="tactic">intros</span> [ | <span class="id" type="var">i</span> <span class="id" type="var">p</span>] <span class="id" type="var">Hsubterm</span>.<br/>
<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hsubterm</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hsubterm'</span> := <span class="id" type="var">subterm_at_pos_apply_subst_apply_subst_subterm_at_pos</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">k</span>) (<span class="id" type="var">i</span> :: <span class="id" type="var">p</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <span class="id" type="var">nil</span>)).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsubterm</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsubterm'</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_is_sound</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">var_in_subterm</span> <span class="id" type="var">y</span> <span class="id" type="var">_</span> (<span class="id" type="var">i</span> :: <span class="id" type="var">p</span>) <span class="id" type="var">Hsubterm'</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_not_in_l</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hsrc</span> := <span class="id" type="var">is_a_cycle_all_var_inst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hcycle</span> <span class="id" type="var">src</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> [<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l</span>] | <span class="id" type="var">idtac</span>];<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">src_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">src_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsrc</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hsrc</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">Hsrc</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hnext</span> := <span class="id" type="var">is_a_cycle_all_var_inst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hcycle</span> <span class="id" type="var">next</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">next</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intros</span> [<span class="id" type="var">v</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>] | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">next_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hnext</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hnext</span>; <span class="id" type="var">right</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">Hnext</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">pattern</span> (<span class="id" type="var">next'</span> :: <span class="id" type="var">c</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">src_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">next</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); [<span class="id" type="tactic">intro</span> <span class="id" type="var">next_in_l</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">next_not_in_l</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_in_l</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">next'</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">k</span>)); [<span class="id" type="tactic">intro</span> <span class="id" type="var">next'_in_k</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">next'_not_in_k</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next'_in_k</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map</span> <span class="id" type="var">X.eq_bool</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <span class="id" type="var">nil</span>)) <span class="id" type="var">next</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">apply_subst</span> <span class="id" type="tactic">at</span> 1 <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="var">apply_subst</span> <span class="id" type="tactic">at</span> 1; <span class="id" type="var">cbv</span> <span class="id" type="var">iota</span> <span class="id" type="var">beta</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="var">var_in_term</span> <span class="id" type="var">next'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <span class="id" type="var">nil</span>) (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">k</span>)) = <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">next'_in_k</span>.<br/>
<span class="id" type="tactic">case</span> (<span class="id" type="var">var_in_subterm2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">in_impl_mem</span> (@<span class="id" type="var">eq</span> <span class="id" type="var">_</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> =&gt; <span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">next'_in_k</span>)); <span class="id" type="tactic">intros</span> [ | <span class="id" type="var">i</span> <span class="id" type="var">p</span>] <span class="id" type="var">Hsubterm</span>.<br/>
<span class="id" type="tactic">inversion</span> <span class="id" type="var">Hsubterm</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hsubterm'</span> := <span class="id" type="var">subterm_at_pos_apply_subst_apply_subst_subterm_at_pos</span> (<span class="id" type="var">Term</span> <span class="id" type="var">g</span> <span class="id" type="var">k</span>) (<span class="id" type="var">i</span> :: <span class="id" type="var">p</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) :: <span class="id" type="var">nil</span>)).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsubterm</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hsubterm'</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_is_sound</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">var_in_subterm</span> <span class="id" type="var">next'</span> <span class="id" type="var">_</span> (<span class="id" type="var">i</span> :: <span class="id" type="var">p</span>) <span class="id" type="var">Hsubterm'</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">next'</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">next'</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">next'_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">next'</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">W'</span> : <span class="id" type="var">VSet.without_red</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">x</span> :: <span class="id" type="var">c</span>)).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.without_red_remove</span> <span class="id" type="var">next</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">nil</span>) (<span class="id" type="var">x</span> :: <span class="id" type="var">c</span>) <span class="id" type="var">W</span>).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W'</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.without_red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W'</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W'</span>; <span class="id" type="var">revert</span> <span class="id" type="var">W'</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_bool</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">next</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">y_in_x_sigma</span> <span class="id" type="var">Hx</span> <span class="id" type="var">_</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.without_red_remove</span> <span class="id" type="var">next</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">nil</span>) (<span class="id" type="var">next'</span> :: <span class="id" type="var">c</span>) <span class="id" type="var">W</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_sigma</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next'_in_k</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next'_not_in_k</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">next_not_in_l</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hnext</span>; <span class="id" type="var">right</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Hsrc</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span> <span class="id" type="var">W</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span> <span class="id" type="keyword">with</span> <span class="id" type="var">src</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hcycle</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">src</span> <span class="id" type="var">sigma</span>) <span class="id" type="keyword">as</span> [[<span class="id" type="var">v</span> | <span class="id" type="var">f</span> <span class="id" type="var">l</span>] | ].<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">next</span> (<span class="id" type="var">Term</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>)); <span class="id" type="tactic">trivial</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">is_a_cycle_all_var_inst</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hcycle</span>); <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>

<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.without_red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W</span>; <span class="id" type="var">revert</span> <span class="id" type="var">W</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_bool</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">src</span> <span class="id" type="var">next</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">src_eq_next</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">src_diff_next</span>].<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.A</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">src</span> <span class="id" type="var">c</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">src</span> <span class="id" type="var">c</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">src_in_c</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">src_not_in_c</span>].<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">mem_bool_ok</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">next</span> <span class="id" type="var">c</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">mem_bool</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">next</span> <span class="id" type="var">c</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">next_in_c</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">next_not_in_c</span>].<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> [<span class="id" type="var">src_eq_next</span> | <span class="id" type="var">src_in_c</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">src_diff_next</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">src_not_in_c</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">in_impl_mem</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">idem_sol</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>) -&gt; <span class="id" type="var">VSet.mem</span> <span class="id" type="var">y</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">var_in_term</span> <span class="id" type="var">x</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>)) = <span class="id" type="var">false</span>) -&gt; <br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">nil</span>) <span class="id" type="var">sigma</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">Idem</span>; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">apply_subst_outside_dom</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">split</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">intro</span>; <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H1</span> := <span class="id" type="var">VSet.inter_1</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H2</span> := <span class="id" type="var">VSet.inter_2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>).<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H3</span> : <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_domain_of_subst</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hi</span> := <span class="id" type="var">Idem</span> <span class="id" type="var">y</span> <span class="id" type="var">x</span> <span class="id" type="var">H1</span> <span class="id" type="var">H3</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H2'</span> : <span class="id" type="var">In</span> <span class="id" type="var">y</span> (<span class="id" type="var">var_list</span> <span class="id" type="var">x_val</span>)).<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">H2</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; [<span class="id" type="tactic">intro</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>].<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>, <span class="id" type="var">VSet.singleton</span>, <span class="id" type="var">DecVar.eq_A</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>]; [<span class="id" type="tactic">subst</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span> | <span class="id" type="var">contradiction</span>].<br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">t</span> <span class="id" type="var">l</span>].<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>, <span class="id" type="var">VSet.singleton</span>, <span class="id" type="var">DecVar.eq_A</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">IH</span> <span class="id" type="var">y_in_tl</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">set_of_variables</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_tl</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.union_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">y_in_tl</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">y_in_t</span> | <span class="id" type="var">y_in_l</span>].<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">in_or_app</span>; <span class="id" type="var">left</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">IH</span> <span class="id" type="var">t</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>)) <span class="id" type="var">y_in_t</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">in_or_app</span>; <span class="id" type="var">right</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">IHl</span> <span class="id" type="var">_</span> <span class="id" type="var">y_in_l</span>).<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>.<br/>
<span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H2'</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hi</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hi</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hi</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H2'</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> {<span class="id" type="keyword">struct</span> <span class="id" type="var">c</span>} :=<br/>
<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">true</span><br/>
| <span class="id" type="var">x</span> :: <span class="id" type="var">c'</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">vx</span> := <span class="id" type="var">Var</span> <span class="id" type="var">x</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">v_val</span> := <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> <span class="id" type="var">vx</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">list_exists</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span>) <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">then</span> <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c'</span><br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span> {<span class="id" type="keyword">struct</span> <span class="id" type="var">c</span>} :=<br/>
<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">sigma</span><br/>
| <span class="id" type="var">x</span> :: <span class="id" type="var">c'</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">xxval</span> := (<span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">xxval_subst</span> := <span class="id" type="var">xxval</span> :: <span class="id" type="var">nil</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">acc_inst</span> <span class="id" type="var">c'</span> (<span class="id" type="var">map_subst</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> <span class="id" type="var">t</span> =&gt; (<span class="id" type="var">apply_subst</span> <span class="id" type="var">xxval_subst</span> <span class="id" type="var">t</span>)) <span class="id" type="var">sigma</span>))<br/>
<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">acc_inst_dom</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>, <span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">domain_of_subst</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">x</span> <span class="id" type="var">l</span>]; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">IHl</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">domain_of_subst_map_subst</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">elim_var_in_subst</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">z</span>, <span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>) -&gt;<br/>
<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> = <span class="id" type="var">false</span> -&gt;<br/>
<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> (<span class="id" type="var">map_subst</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>,v_val) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>) <span class="id" type="var">sigma</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">z</span>)) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">y</span> <span class="id" type="var">y_in_dom</span> <span class="id" type="var">v_in_v_val</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_domain_of_subst</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">y_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">y_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">y_val</span>) &lt;&gt; <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_subterm2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">in_impl_mem</span> (@<span class="id" type="var">eq</span> <span class="id" type="var">_</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> =&gt; <span class="id" type="var">refl_equal</span> <span class="id" type="var">a</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H1</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">p</span> <span class="id" type="var">H'''</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H4</span> := <span class="id" type="var">subterm_in_instantiated_term</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H'''</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">subterm_at_pos</span> <span class="id" type="var">y_val</span> <span class="id" type="var">p</span>); [<span class="id" type="tactic">intros</span> [<span class="id" type="var">w</span> | <span class="id" type="var">f</span> <span class="id" type="var">l</span>] | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">Hsub</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsub</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H4</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H4</span>; <span class="id" type="var">revert</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">w</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">w</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">w_eq_v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">w_diff_v</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">w</span> <span class="id" type="var">v_val</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">v_in_v_val'</span> : <span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>) = <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>);  [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_v</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">v_diff_v</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">v_in_v_val'</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">w_diff_v</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">w</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">H4</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">w</span> [<span class="id" type="var">q</span> [<span class="id" type="var">q'</span> [<span class="id" type="var">H4</span> [<span class="id" type="var">H5</span> [<span class="id" type="var">H6</span> <span class="id" type="var">H7</span>]]]]]].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H7</span>; <span class="id" type="var">revert</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">w</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">w</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">w_eq_v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">w_diff_v</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">w</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">x_in_v_val</span> := <span class="id" type="var">var_in_subterm</span> <span class="id" type="var">v</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H7</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_v_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_v_val</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">q'</span>; [<span class="id" type="tactic">injection</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">w</span> | <span class="id" type="tactic">discriminate</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">w_diff_v</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">y_val</span>)); [<span class="id" type="var">absurd</span> (<span class="id" type="var">true</span> = <span class="id" type="var">true</span>) | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom</span>; <span class="id" type="var">absurd</span> (@<span class="id" type="var">None</span> <span class="id" type="var">term</span> = <span class="id" type="var">None</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">no_var_in_term_inv</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span> <span class="id" type="var">y_val</span> <span class="id" type="var">z</span>, <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">x_val</span> = <span class="id" type="var">false</span> -&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">y_val</span> = <span class="id" type="var">false</span> -&gt;<br/>
<span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>,x_val) :: <span class="id" type="var">nil</span>) <span class="id" type="var">y_val</span>) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span> <span class="id" type="var">w_val'</span> <span class="id" type="var">z</span> <span class="id" type="var">z_not_in_x_val</span> <span class="id" type="var">z_not_in_w_val'</span>;<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">x_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">w_val'</span>) &lt;&gt; <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_subterm2</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> (<span class="id" type="var">in_impl_mem</span> (@<span class="id" type="var">eq</span> <span class="id" type="var">_</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span> =&gt; <span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>) <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H1</span>)) <span class="id" type="keyword">as</span> [<span class="id" type="var">p</span> <span class="id" type="var">H'''</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H4</span> := <span class="id" type="var">subterm_in_instantiated_term</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H'''</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">subterm_at_pos</span> <span class="id" type="var">w_val'</span> <span class="id" type="var">p</span>); [<span class="id" type="tactic">intros</span> [<span class="id" type="var">u</span> | <span class="id" type="var">f</span> <span class="id" type="var">l</span>] | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">Hsub</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsub</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H4</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H4</span>; <span class="id" type="var">revert</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">u</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">u</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">u_eq_x</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">u_diff_x</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">u</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">z_in_x_val'</span> : <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> (<span class="id" type="var">Var</span> <span class="id" type="var">z</span>) = <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">z</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_z</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">z_diff_z</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_in_x_val'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">z_not_in_x_val</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">u</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">z_in_w_val'</span> := <span class="id" type="var">var_in_subterm</span> <span class="id" type="var">z</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hsub</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">z_in_w_val'</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_not_in_w_val'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">z_in_w_val'</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">H4</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">u</span> [<span class="id" type="var">q</span> [<span class="id" type="var">q'</span> [<span class="id" type="var">H4</span> [<span class="id" type="var">H5</span> [<span class="id" type="var">H6</span> <span class="id" type="var">H7</span>]]]]]].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H7</span>; <span class="id" type="var">revert</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">u</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">u</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">u_eq_x</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">u_diff_x</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">u</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">z_in_x_val</span> := <span class="id" type="var">var_in_subterm</span> <span class="id" type="var">z</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H7</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">z_in_x_val</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_not_in_x_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">z_in_x_val</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">q'</span>; [<span class="id" type="tactic">injection</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H7</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">u</span> | <span class="id" type="tactic">discriminate</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">app_nil_end</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H4</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">q</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hsub</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H6</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">x_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">w_val'</span>)); [<span class="id" type="var">absurd</span> (<span class="id" type="var">true</span> = <span class="id" type="var">true</span>) | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">no_var_in_subst_inv</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>, <br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span>, <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">Some</span> <span class="id" type="var">v_val</span> -&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span> = <span class="id" type="var">false</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span>, <span class="id" type="var">VSet.mem</span> <span class="id" type="var">v</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>) -&gt; <br/>
&nbsp;&nbsp;<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) = <span class="id" type="var">Some</span> <span class="id" type="var">v_val</span> -&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span> <span class="id" type="var">H</span> <span class="id" type="var">c</span>; <span class="id" type="var">revert</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span> <span class="id" type="var">H</span>; <br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">x</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span> <span class="id" type="var">H</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">v_in_dom</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">H</span> <span class="id" type="var">v</span> <span class="id" type="var">_</span> <span class="id" type="var">F</span>).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">F</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">w</span> <span class="id" type="var">w_val</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F'</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">w</span> <span class="id" type="var">x</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">w</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">w_val'</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">w_sigma</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">w_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">injection</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">F</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">w_val</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">z_not_in_w_val'</span> := <span class="id" type="var">H</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">w_sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">z_not_in_x_val</span> := <span class="id" type="var">H</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">x_sigma</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">no_var_in_term_inv</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">replace</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">x</span>, <span class="id" type="var">Var</span> <span class="id" type="var">x</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">w_val'</span>) <span class="id" type="keyword">with</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">nil</span> <span class="id" type="var">w_val'</span>).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">empty_subst_is_id</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">y</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">y</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">y_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">y</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_diff_x</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">domain_of_subst_map_subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">total_ordering_eq_subst</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span>, (<span class="id" type="keyword">forall</span> <span class="id" type="var">v</span>, <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">tau</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> = <span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">tau</span> <span class="id" type="var">c</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">v</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">acc_inst_eq_subst</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span>, (<span class="id" type="keyword">forall</span> <span class="id" type="var">v</span>, <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">tau</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">v</span>, <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) = <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">tau</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">v</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">refine</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F'</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">tau</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">tau</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">tail_total_ordering</span> :<br/>
<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">c</span>,<br/>
<span class="id" type="var">list_exists</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span>) <span class="id" type="var">c</span> = <span class="id" type="var">false</span> -&gt;<br/>
<span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt;<br/>
<span class="id" type="var">is_a_total_oc_ordering</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt; <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sigma</span>) <span class="id" type="var">c</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">z</span> <span class="id" type="var">l</span>]; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">z</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">z_sigma</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">z_val</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">z_in_z_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">z_in_z_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H'</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">no_var_in_term_inv</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">z_val</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_v_val</span> <span class="id" type="var">z_in_z_val</span>).<br/>
<span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">list_exists</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">z_val</span>) <span class="id" type="var">l</span>); <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Hoc'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hoc'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hoc''</span> :=  <span class="id" type="var">list_exists_is_complete_false</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hoc'</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">list_exists</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">z0</span> : <span class="id" type="var">variable</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">var_in_term</span> <span class="id" type="var">z0</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">z_val</span>)) <span class="id" type="var">l</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">Goc</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">list_exists_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Goc</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">Goc</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">w</span> [<span class="id" type="var">w_in_l</span> <span class="id" type="var">Goc'</span>]].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">Goc'</span>; <span class="id" type="tactic">symmetry</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">no_var_in_term_inv</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">list_exists_is_complete_false</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H'</span> <span class="id" type="var">w</span> <span class="id" type="var">w_in_l</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">Hoc''</span> <span class="id" type="var">w</span> <span class="id" type="var">w_in_l</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">z</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">z</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_z</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">z_diff_z</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">total_acc_inst_head</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>, <span class="id" type="var">VSet.without_red</span> (<span class="id" type="var">v</span> :: <span class="id" type="var">c</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">v</span> :: <span class="id" type="var">c</span>) = <span class="id" type="var">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> (<span class="id" type="var">acc_inst</span> (<span class="id" type="var">v</span> :: <span class="id" type="var">c</span>) <span class="id" type="var">sigma</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>) = <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">v'</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> <span class="id" type="var">W</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">sigma</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">empty_subst_is_id</span> <span class="id" type="var">v_val</span>) <span class="id" type="tactic">at</span> 3.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">y</span> <span class="id" type="var">y_in_v_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">y_eq_v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_diff_v</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>.<br/>

<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">v_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Idem</span> : <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>,v_val) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_val</span> = <span class="id" type="var">v_val</span>).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">empty_subst_is_id</span> <span class="id" type="var">v_val</span>) <span class="id" type="tactic">at</span> 3.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">y</span> <span class="id" type="var">y_in_v_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">y_eq_v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">y_diff_v</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">v_in_v_val</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F'</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">v'</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">sigma</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v'</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v'_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">v'_sigma</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v'_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F'</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Switch</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">y</span>, <br/>
<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span><br/>
(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v'</span>, <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) :: <span class="id" type="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>) <span class="id" type="var">sigma</span>)) =<br/>
<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span><br/>
(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)<br/>
(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v'</span>, <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) :: <span class="id" type="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">t</span>) <span class="id" type="var">sigma</span>))).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">y</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Fy</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Fy'</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">y</span> <span class="id" type="var">v'</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt; <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Fy''</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">y</span> <span class="id" type="var">v'</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Fy'''</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> (<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v'</span>, <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">y_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">y_sigma</span>;<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.A</span> <span class="id" type="keyword">in</span> *; <br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Fy</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Fy</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Fy'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Fy'</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Fy''</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Fy''</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Fy'''</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Fy'''</span>; [<span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span> | <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">do</span> 2 <span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_y_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">z</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">z_eq_v</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">z</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">z_diff_v</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">v'</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">v'</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_v'</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v'</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_v'</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.without_red</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">W</span>; <span class="id" type="var">revert</span> <span class="id" type="var">W</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_bool</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); <br/>
[<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">v_diff_v</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">v_diff_v</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">empty_subst_is_id</span> <span class="id" type="var">v_val</span>) <span class="id" type="tactic">at</span> 3.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">u_in_v_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">u</span> <span class="id" type="var">v'</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">u</span> <span class="id" type="var">v'</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">u_eq_v'</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v'</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">u_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">u_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v'</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v'</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v'_eq_v</span>; <span class="id" type="var">absurd</span> (<span class="id" type="var">v'</span> = <span class="id" type="var">v</span>); <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">W</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.without_red</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_bool</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">v'</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">v'</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_v'</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_v'</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">v'</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span> <span class="id" type="var">v'</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">z_eq_v'</span> | <span class="id" type="var">z_diff_v'</span>]; [<span class="id" type="var">idtac</span> | <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">u_in_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">u</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">u_eq_v</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Idem</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">acc_inst_eq_subst</span> <span class="id" type="var">c</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Switch</span>); <span class="id" type="tactic">clear</span> <span class="id" type="var">Switch</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">IH</span> := <span class="id" type="var">IHc</span> <span class="id" type="var">v</span> (<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">v'</span>, <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sigma</span>) (<span class="id" type="var">VSet.without_red_remove</span> <span class="id" type="var">v'</span> (<span class="id" type="var">v</span> :: <span class="id" type="var">nil</span>) <span class="id" type="var">c</span> <span class="id" type="var">W</span>)).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">IH</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">v</span> <span class="id" type="var">v'</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.A</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span> <span class="id" type="keyword">in</span> <span class="id" type="var">IH</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Idem'</span> : <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v'</span>, <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v_val</span> = <span class="id" type="var">v_val</span>).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">empty_subst_is_id</span> <span class="id" type="var">v_val</span>) <span class="id" type="tactic">at</span> 3.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">u_in_v_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">u</span> <span class="id" type="var">v'</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">u</span> <span class="id" type="var">v'</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">u_eq_v'</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v'</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">u_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">u_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Idem'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">clear</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_in_v_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v'</span> <span class="id" type="var">v_val</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">v'_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v'_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v'_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">list_exists</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span>) <span class="id" type="var">c</span>); <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Hoc'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hoc'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v'</span> <span class="id" type="var">v'_val</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">v'_in_v'_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v'_in_v'_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">list_exists</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v'_val</span>) <span class="id" type="var">c</span>); <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">Hoc''</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hoc''</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">tail_total_ordering</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="var">list_exists</span><br/>
&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>))<br/>
&nbsp;&nbsp;<span class="id" type="var">c</span> &lt;&gt; <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">list_exists_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">z</span> [<span class="id" type="var">z_in_c</span> <span class="id" type="var">z_in_val</span>]].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">no_var_in_term_inv</span> <span class="id" type="keyword">in</span> <span class="id" type="var">z_in_val</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">list_exists_is_complete_false</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hoc'</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_c</span>).<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">list_exists_is_complete_false</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hoc''</span> <span class="id" type="var">_</span> <span class="id" type="var">z_in_c</span>).<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">list_exists</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">v'_val</span>)) <span class="id" type="var">c</span>); [<span class="id" type="var">absurd</span> (<span class="id" type="var">true</span> = <span class="id" type="var">true</span>) | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v'_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v'</span> <span class="id" type="var">v_val</span>); [<span class="id" type="tactic">discriminate</span> | <span class="id" type="var">idtac</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">list_exists</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span>) <span class="id" type="var">c</span>); [<span class="id" type="tactic">discriminate</span> | <span class="id" type="var">idtac</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="var">revert</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v'</span> <span class="id" type="var">v'</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v'</span> <span class="id" type="var">v'</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v'_diff_v'</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">v'_diff_v'</span>; <span class="id" type="tactic">reflexivity</span>].<br/>

<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="var">revert</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_v</span>]; [<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="var">absurd</span> (<span class="id" type="var">v</span> = <span class="id" type="var">v</span>); <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">total_acc_inst_elim_var</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span> <span class="id" type="var">v</span>, <br/>
&nbsp;&nbsp;<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) = <span class="id" type="var">false</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">x_val</span>, <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span> = <span class="id" type="var">Some</span> <span class="id" type="var">x_val</span> -&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> <span class="id" type="var">x_val</span> = <span class="id" type="var">false</span>) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>, <span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) <span class="id" type="var">t</span>) = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">v</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">x</span> <span class="id" type="var">x_elim_x</span> <span class="id" type="var">sigma_elim_x</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_elim_x</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_elim_x</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">simpl</span>; <br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">sigma_elim_x</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">v_sigma</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="var">revert</span> <span class="id" type="var">x_elim_x</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">x_diff_x</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">t</span> <span class="id" type="var">l</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">IH</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> <span class="id" type="var">t</span>) (<span class="id" type="var">IH</span> <span class="id" type="var">t</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))).<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">w</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>] <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_list_equation</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="var">revert</span> <span class="id" type="var">H</span>; <br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">w</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">w</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> <span class="id" type="var">Abs</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">w_diff_x</span>].<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">w</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">w</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">x_eq_w</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>].<br/>
<span class="id" type="var">absurd</span> (<span class="id" type="var">w</span>=x); <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHc</span>.<br/>
<span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_elim_x</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_elim_x</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.A</span> <span class="id" type="keyword">in</span> *; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">no_var_in_term_inv</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">sigma_elim_x</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">v_sigma</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_elim_x</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_elim_x</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">y</span> <span class="id" type="var">y_val'</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F'</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">y</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">y_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">y_sigma</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">y_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>.<br/>
<span class="id" type="tactic">injection</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">y_val'</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">no_var_in_term_inv</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> := <span class="id" type="var">sigma_elim_x</span> <span class="id" type="var">v</span>).<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">x</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">sigma_elim_x</span> <span class="id" type="var">y</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">discriminate</span>.<br/>

<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">x_elim_x</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">x</span>); <br/>
[<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">x_diff_x</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">set_of_var_list_of_var</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">v</span> <span class="id" type="var">t</span>, <span class="id" type="var">VSet.mem</span> <span class="id" type="var">v</span> (<span class="id" type="var">set_of_variables</span> <span class="id" type="var">t</span>) &lt;-&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> <span class="id" type="var">t</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">pattern</span> <span class="id" type="var">t</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">term_rec3</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">t</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_A</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">v</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">intuition</span>.<br/>
<span class="id" type="tactic">intuition</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">IH</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">t</span> <span class="id" type="var">l</span>]; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intuition</span>.<br/>
<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">VSet.union_12</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">H1</span> | <span class="id" type="var">H2</span>].<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IH</span> <span class="id" type="var">t</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))) <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_list_equation</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">w</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>]; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_w</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">False_rec</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">v_diff_w</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">w</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">intro</span>; <span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">assumption</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H1</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H2</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_list_equation</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">w</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>]; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">trivial</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_w</span>].<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H2</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Bool.orb_true_r</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">H2</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Bool.orb_true_r</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">u_in_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_term_list_equation</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">t</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">w</span> | <span class="id" type="var">g</span> <span class="id" type="var">k</span>]; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">w</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">v_eq_w</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">w</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">v_diff_w</span> <span class="id" type="var">H</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="var">left</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">u_in_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term_list</span> <span class="id" type="var">v</span> <span class="id" type="var">k</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">v_in_k</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_in_k</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_1</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IH</span> <span class="id" type="var">_</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">VSet.union_2</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">u</span> <span class="id" type="var">u_in_l</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IH</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">total_acc_inst_idem</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>, <span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">VSet.without_red</span> <span class="id" type="var">c</span> -&gt;<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, <span class="id" type="var">In</span> <span class="id" type="var">x</span> <span class="id" type="var">c</span> -&gt; <span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)) -&gt;<br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span>, <span class="id" type="var">In</span> <span class="id" type="var">x</span> <span class="id" type="var">c</span> -&gt; <span class="id" type="var">In</span> <span class="id" type="var">y</span> <span class="id" type="var">c</span> -&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">x</span> (<span class="id" type="var">apply_subst</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>)) = <span class="id" type="var">false</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">v</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">Hoc</span> <span class="id" type="var">W</span> <span class="id" type="var">H</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">x_in_dom</span> <span class="id" type="var">y_in_dom</span>.<br/>
<span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">v_case</span> := <span class="id" type="var">total_acc_inst_head</span> <span class="id" type="var">c</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> <span class="id" type="var">W</span> <span class="id" type="var">Hoc</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">v_in_dom</span> := <span class="id" type="var">H</span> <span class="id" type="var">v</span> (<span class="id" type="var">or_introl</span> <span class="id" type="var">_</span> (<span class="id" type="var">refl_equal</span> <span class="id" type="var">_</span>))); <span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_domain_of_subst</span> <span class="id" type="keyword">in</span> <span class="id" type="var">v_in_dom</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">v_in_dom</span>; [ <span class="id" type="tactic">clear</span> <span class="id" type="var">v_in_dom</span> | <span class="id" type="var">absurd</span> (@<span class="id" type="var">None</span> <span class="id" type="var">term</span> = <span class="id" type="var">None</span>); <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">v_in_v_val</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">list_exists</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt; <span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span> <span class="id" type="var">v_val</span>) <span class="id" type="var">c</span>);  <span class="id" type="tactic">intro</span> <span class="id" type="var">H'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">y_in_dom</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">y_eq_v</span> | <span class="id" type="var">y_in_dom</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">y</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.A</span> <span class="id" type="keyword">in</span> *;  <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_case</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_dom</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_dom</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_v</span> | <span class="id" type="var">x_in_dom</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">list_exists_is_complete_false</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">H'</span> <span class="id" type="var">_</span> <span class="id" type="var">x_in_dom</span>).<br/>

<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_dom</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">x_in_dom</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">x_eq_v</span> | <span class="id" type="var">x_in_dom</span>].<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">x</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">no_var_in_subst_inv</span> <span class="id" type="var">v</span><br/>
(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>) <span class="id" type="var">sigma</span>)) <span class="id" type="keyword">with</span> <span class="id" type="var">c</span> <span class="id" type="var">y</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_val</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H''</span> := <span class="id" type="var">elim_var_in_subst</span> <span class="id" type="var">sigma</span> <span class="id" type="var">v</span> <span class="id" type="var">v_val</span> <span class="id" type="var">z</span>).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H''</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H''</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">H''</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F'</span> : <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt; <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sigma</span>) &lt;&gt; <span class="id" type="var">None</span>).<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_domain_of_subst</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">domain_of_subst_map_subst</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">domain_of_subst_map_subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">y_in_dom'</span> : <span class="id" type="var">VSet.mem</span> <span class="id" type="var">y</span> (<span class="id" type="var">domain_of_subst</span> (<span class="id" type="var">acc_inst</span> (<span class="id" type="var">v</span> :: <span class="id" type="var">c</span>) <span class="id" type="var">sigma</span>))).<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">acc_inst_dom</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">var_in_domain_of_subst</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom'</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom'</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">y</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt; <span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">v_val</span>) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">sigma</span>))); [<span class="id" type="var">idtac</span> | <span class="id" type="var">absurd</span> (@<span class="id" type="var">None</span> <span class="id" type="var">term</span> = <span class="id" type="var">None</span>)]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">IHc</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">tail_total_ordering</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.without_red_remove</span> <span class="id" type="var">v</span> <span class="id" type="var">nil</span> <span class="id" type="var">c</span> <span class="id" type="var">W</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">w</span> <span class="id" type="var">w_in_c</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">domain_of_subst_map_subst</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>; <span class="id" type="var">right</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">total_acc_inst_sol</span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span>, <span class="id" type="var">VSet.without_red</span> <span class="id" type="var">c</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">VSet.LP.permut</span> <span class="id" type="var">c</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) <span class="id" type="var">nil</span>) (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> <span class="id" type="var">W</span> <span class="id" type="var">Hoc</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">idem_sol</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">H</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">z</span>, <span class="id" type="var">In</span> <span class="id" type="var">z</span> <span class="id" type="var">c</span> -&gt; <span class="id" type="var">VSet.mem</span> <span class="id" type="var">z</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>)).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_c</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">VSet.LP.mem_permut_mem</span> <span class="id" type="var">z</span> <span class="id" type="var">P</span>).<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">in_impl_mem</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">x_in_dom</span> <span class="id" type="var">y_in_dom</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">total_acc_inst_idem</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">acc_inst_dom</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_dom</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">VSet.LP.mem_permut_mem</span> <span class="id" type="var">x</span> <span class="id" type="var">P</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_dom</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">x_in_dom</span>; <span class="id" type="tactic">generalize</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">u</span> <span class="id" type="var">l</span>]; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_A</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">x_eq_u</span> | <span class="id" type="var">x_in_l</span>]; [<span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span> | <span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">acc_inst_dom</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">VSet.LP.mem_permut_mem</span> <span class="id" type="var">y</span> <span class="id" type="var">P</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">y_in_dom</span>; <span class="id" type="tactic">generalize</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">u</span> <span class="id" type="var">l</span>]; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">unfold</span> <span class="id" type="var">DecVar.eq_A</span>; <span class="id" type="tactic">intros</span> [<span class="id" type="var">y_eq_u</span> | <span class="id" type="var">y_in_l</span>]; [<span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">reflexivity</span> | <span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>; <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">total_acc_inst_inv</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span>, <span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) <span class="id" type="var">nil</span>) <span class="id" type="var">tau</span> &lt;-&gt; <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">nil</span>) <span class="id" type="var">tau</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">c</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">v</span> <span class="id" type="var">c</span>]; <span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">tau</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">intuition</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">equiv_sol</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">rho</span> <span class="id" type="var">rho'</span> <span class="id" type="var">sol</span>, (<span class="id" type="keyword">forall</span> <span class="id" type="var">v</span>, <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">rho</span> = <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">rho'</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">rho</span> <span class="id" type="var">nil</span>) <span class="id" type="var">sol</span> -&gt; <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">rho'</span> <span class="id" type="var">nil</span>) <span class="id" type="var">sol</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">rho</span> <span class="id" type="var">rho'</span> <span class="id" type="var">sol</span> <span class="id" type="var">r_eq_r'</span> [<span class="id" type="var">_</span> <span class="id" type="var">Sol'</span>]; <span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">Solx</span> := <span class="id" type="var">Sol'</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Solx</span>; <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">r_eq_r'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Solx</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Hoc'</span> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">is_a_total_oc_ordering</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">map_subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">_</span> : <span class="id" type="var">variable</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">term</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) :: <span class="id" type="var">nil</span>) <span class="id" type="var">t</span>) <span class="id" type="var">sigma</span>) <span class="id" type="var">c</span> = <span class="id" type="var">true</span>).<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">var_in_term</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">v_sigma</span> =&gt; <span class="id" type="var">v_sigma</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">Var</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>); [<span class="id" type="tactic">discriminate</span> | <span class="id" type="var">idtac</span>].<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">list_exists</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">z</span> : <span class="id" type="var">variable</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">var_in_term</span> <span class="id" type="var">z</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">v_sigma</span> =&gt; <span class="id" type="var">v_sigma</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> =&gt; <span class="id" type="var">Var</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>) <span class="id" type="var">c</span>); <span class="id" type="tactic">intro</span> <span class="id" type="var">Hoc'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hoc'</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; [<span class="id" type="tactic">discriminate</span> | <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>].<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">tail_total_ordering</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">Sol</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">IHc</span> <span class="id" type="var">_</span> <span class="id" type="var">tau</span> <span class="id" type="var">Hoc'</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">Sol</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">rep_var_is_complete</span> <span class="id" type="var">v</span>).<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">equiv_sol</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Sol</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F'</span> := <span class="id" type="var">find_map</span> <span class="id" type="var">X.eq_bool</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) :: <span class="id" type="var">nil</span>)) <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">x</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_x</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">empty_subst_is_id</span> <span class="id" type="var">v_val</span>) <span class="id" type="tactic">at</span> 3.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">x_in_v_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">reflexivity</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_v_val</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="var">revert</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_v</span>]; [<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="var">absurd</span> (<span class="id" type="var">v</span> = <span class="id" type="var">v</span>); <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHc</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> (<span class="id" type="var">rep_var_is_complete</span> <span class="id" type="var">v</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">Sol</span>.<br/>
<span class="id" type="tactic">refine</span> (<span class="id" type="var">equiv_sol</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Sol</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">F</span> := <span class="id" type="var">find_map_subst</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span> (<span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">F'</span> := <span class="id" type="var">find_map</span> <span class="id" type="var">X.eq_bool</span> (<span class="id" type="var">apply_subst</span> ((<span class="id" type="var">v</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">sigma</span> (<span class="id" type="var">Var</span> <span class="id" type="var">v</span>)) :: <span class="id" type="var">nil</span>)) <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">x_diff_v</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_val</span> | <span class="id" type="var">idtac</span>]; <span class="id" type="tactic">intro</span> <span class="id" type="var">v_sigma</span>;<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>.<br/>
<span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">apply</span> <span class="id" type="tactic">f_equal</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">empty_subst_is_id</span> <span class="id" type="var">v_val</span>) <span class="id" type="tactic">at</span> 3.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">x_in_v_val</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">v_eq_x</span>; <span class="id" type="tactic">subst</span> <span class="id" type="var">x</span> | <span class="id" type="tactic">intros</span> <span class="id" type="var">x_diff_v</span>].<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">var_in_term_is_sound</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_v_val</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_in_v_val</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">discriminate</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">v_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Hoc</span>; <span class="id" type="var">revert</span> <span class="id" type="var">Hoc</span>.<br/>
<span class="id" type="tactic">generalize</span> (<span class="id" type="var">X.eq_bool_ok</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); <span class="id" type="tactic">case</span> (<span class="id" type="var">X.eq_bool</span> <span class="id" type="var">v</span> <span class="id" type="var">v</span>); [<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span> | <span class="id" type="tactic">intro</span> <span class="id" type="var">v_diff_v</span>]; [<span class="id" type="tactic">intros</span>; <span class="id" type="tactic">discriminate</span> | <span class="id" type="var">absurd</span> (<span class="id" type="var">v</span> = <span class="id" type="var">v</span>); <span class="id" type="tactic">trivial</span>].<br/>
<span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">sigma</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span>]; <br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_sigma</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_sigma</span> <span class="id" type="keyword">in</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">F'</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">mgu_founded</span> :<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span>, <span class="id" type="var">is_a_total_oc_ordering</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="var">VSet.without_red</span> <span class="id" type="var">c</span> -&gt;<br/>
&nbsp;(<span class="id" type="var">VSet.LP.permut</span> <span class="id" type="var">c</span> (<span class="id" type="var">VSet.support</span> (<span class="id" type="var">domain_of_subst</span> <span class="id" type="var">sigma</span>))) -&gt;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">tau</span>, <span class="id" type="var">is_a_solution</span> (<span class="id" type="var">mk_pb</span> <span class="id" type="var">sigma</span> <span class="id" type="var">nil</span>) <span class="id" type="var">tau</span> &lt;-&gt;<br/>
&nbsp;&nbsp;(<span class="id" type="var">exists</span> <span class="id" type="var">theta</span>, <br/>
&nbsp;&nbsp;(<span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>, <span class="id" type="var">apply_subst</span> <span class="id" type="var">tau</span> (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>) = <span class="id" type="var">apply_subst</span> <span class="id" type="var">theta</span> (<span class="id" type="var">apply_subst</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">x</span>)))).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">sigma</span> <span class="id" type="var">c</span> <span class="id" type="var">Hoc</span> <span class="id" type="var">W</span> <span class="id" type="var">c_in_dom</span> <span class="id" type="var">tau</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">total_acc_inst_inv</span> <span class="id" type="var">c</span>); <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">split</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">Sol</span>.<br/>
<span class="id" type="var">exists</span> <span class="id" type="var">tau</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">Sol</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>); <span class="id" type="tactic">intros</span> <span class="id" type="var">rho</span> [<span class="id" type="var">_</span> <span class="id" type="var">Sol</span>].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>; <span class="id" type="tactic">assert</span> (<span class="id" type="var">Solx</span> := <span class="id" type="var">Sol</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Solx</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">tau</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val</span> | <span class="id" type="var">idtac</span> ]; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_tau</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_tau</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Solx</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">rho</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val'</span> | <span class="id" type="var">idtac</span> ]; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_rho</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_rho</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Solx</span>.<br/>
<span class="id" type="tactic">subst</span> <span class="id" type="var">x_val</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_tau</span>; <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">rho</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_val'</span> | <span class="id" type="var">idtac</span> ]; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_rho</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_rho</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Solx</span>.<br/>
<span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_tau</span>; <span class="id" type="tactic">reflexivity</span>.<br/>

<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">Sol</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">theta</span> <span class="id" type="var">Sol</span>].<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Idem</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">variable</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">x</span> (<span class="id" type="var">domain_of_subst</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">VSet.mem</span> <span class="id" type="var">y</span> (<span class="id" type="var">domain_of_subst</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">var_in_term</span> <span class="id" type="var">x</span> (<span class="id" type="var">apply_subst</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>) (<span class="id" type="var">Var</span> <span class="id" type="var">y</span>)) = <span class="id" type="var">false</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">x</span> <span class="id" type="var">y</span> <span class="id" type="var">x_in_dom</span> <span class="id" type="var">y_in_dom</span>; <span class="id" type="tactic">apply</span> (<span class="id" type="var">total_acc_inst_idem</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">Hoc</span> <span class="id" type="var">W</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">z</span> <span class="id" type="var">z_in_c</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">VSet.LP.mem_permut_mem</span> <span class="id" type="var">z</span> <span class="id" type="var">c_in_dom</span>); <span class="id" type="tactic">apply</span> <span class="id" type="var">in_impl_mem</span>; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">acc_inst_dom</span> <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_dom</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">VSet.LP.mem_permut_mem</span> <span class="id" type="var">x</span> <span class="id" type="var">c_in_dom</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">x_in_dom</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">x_in_dom</span>; <span class="id" type="tactic">generalize</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>, <span class="id" type="var">VSet.singleton</span>, <span class="id" type="var">DecVar.eq_A</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">z</span> <span class="id" type="var">l</span>].<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">x_eq_z</span> | <span class="id" type="var">x_in_l</span>]; [<span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span> | <span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>]; <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">acc_inst_dom</span> <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom</span>; <span class="id" type="tactic">rewrite</span> &lt;- (<span class="id" type="var">VSet.LP.mem_permut_mem</span> <span class="id" type="var">y</span> <span class="id" type="var">c_in_dom</span>) <span class="id" type="keyword">in</span> <span class="id" type="var">y_in_dom</span>.<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">y_in_dom</span>; <span class="id" type="tactic">generalize</span> <span class="id" type="var">c</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">VSet.mem</span>, <span class="id" type="var">VSet.singleton</span>, <span class="id" type="var">DecVar.eq_A</span>; <span class="id" type="tactic">simpl</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">l</span>; <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [ | <span class="id" type="var">z</span> <span class="id" type="var">l</span>].<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intros</span> [<span class="id" type="var">y_eq_z</span> | <span class="id" type="var">y_in_l</span>]; [<span class="id" type="var">left</span>; <span class="id" type="tactic">subst</span> | <span class="id" type="var">right</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl</span>]; <span class="id" type="tactic">trivial</span>.<br/>

<br/>
<span class="id" type="var">revert</span> <span class="id" type="var">Sol</span> <span class="id" type="var">Idem</span>; <span class="id" type="tactic">generalize</span> (<span class="id" type="var">acc_inst</span> <span class="id" type="var">c</span> <span class="id" type="var">sigma</span>).<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">rho</span> <span class="id" type="var">Sol_tau</span> <span class="id" type="var">Idem</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Sol_rho</span> := <span class="id" type="var">idem_sol</span> <span class="id" type="var">_</span> <span class="id" type="var">Idem</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">Sol_rho</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">_</span> <span class="id" type="var">Sol_rho</span>].<br/>
<span class="id" type="tactic">split</span>.<br/>
<span class="id" type="tactic">intros</span>; <span class="id" type="var">contradiction</span>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x</span>; <br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Sol_taux</span> := <span class="id" type="var">Sol_tau</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Sol_taux</span>.<br/>
<span class="id" type="tactic">assert</span> (<span class="id" type="var">Sol_rhox</span> := <span class="id" type="var">Sol_rho</span> <span class="id" type="var">x</span>); <span class="id" type="tactic">simpl</span>; <span class="id" type="tactic">simpl</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Sol_rhox</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">rho</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_valr</span> | <span class="id" type="tactic">trivial</span> ].<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">x_rho</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_rho</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Sol_taux</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_rho</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Sol_rhox</span>.<br/>
<span class="id" type="var">case_eq</span> (<span class="id" type="var">find</span> <span class="id" type="var">X.eq_bool</span> <span class="id" type="var">x</span> <span class="id" type="var">tau</span>); [<span class="id" type="tactic">intro</span> <span class="id" type="var">x_valt</span> | <span class="id" type="var">idtac</span> ]; <span class="id" type="tactic">intro</span> <span class="id" type="var">x_tau</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">x_tau</span> <span class="id" type="keyword">in</span> <span class="id" type="var">Sol_taux</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Sol_taux</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Sol_rhox</span> <span class="id" type="tactic">at</span> 1.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Sol_tau</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Sol_taux</span>.<br/>
<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Sol_rhox</span> <span class="id" type="tactic">at</span> 1.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">rewrite</span> &lt;- <span class="id" type="var">subst_eq_vars</span>.<br/>
<span class="id" type="tactic">intros</span> <span class="id" type="var">v</span> <span class="id" type="var">_</span>; <span class="id" type="tactic">rewrite</span> <span class="id" type="var">subst_comp_is_subst_comp</span>.<br/>
<span class="id" type="tactic">symmetry</span>; <span class="id" type="tactic">apply</span> <span class="id" type="var">Sol_tau</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">Make</span>.<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://www.lix.polytechnique.fr/coq/">coqdoc</a>
</div>

</div>

</body>
</html>
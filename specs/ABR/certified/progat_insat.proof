Resetting all values
Opening ../no_rm/progat_insat.spike

Successfully parsed sorts

Successfully parsed constructors

Successfully parsed functions

Successfully parsed axioms
All constructors are free
dico_const_string:
2 --> 0
-23 --> firstAt
7 --> Nil
-16 --> wind
-1 --> PLAN_eq
-24 --> listAt
5 --> false
-12 --> memberE
-11 --> memberT
6 --> C
-21 --> progAt
-22 --> timeAt
-6 --> time
-10 --> memberC
-2 --> OBJ_eq
-13 --> sortedT
-4 --> plus
-17 --> maxEr
-5 --> le
-19 --> insAt
-3 --> nat_eq
3 --> S
-8 --> er
-15 --> listUpTo
-25 --> prog
-26 --> acr1
-18 --> acr
8 --> Cons
-7 --> timel
-20 --> insIn
4 --> true
-9 --> erl
-14 --> sortedE

Successfully parsed statuses
dico_id_status:
Completing status dico with default status "Multiset"
AC symbols: 
Case 0: no AC symbols
Orienting axioms
	[ 77 ] PLAN_eq (Nil, Nil) -> true ;
	[ 78 ] PLAN_eq (Cons (u1, u2), Nil) -> false ;
	[ 79 ] PLAN_eq (Nil, Cons (u1, u2)) -> false ;
	[ 80 ] OBJ_eq (u1, u2) = true => PLAN_eq (Cons (u1, u3), Cons (u2, u4)) -> PLAN_eq (u3, u4) ;
	[ 81 ] OBJ_eq (u1, u2) = false => PLAN_eq (Cons (u1, u3), Cons (u2, u4)) -> false ;
	[ 82 ] nat_eq (u1, u2) = true /\ nat_eq (u3, u4) = true => OBJ_eq (C (u1, u3), C (u2, u4)) -> true ;
	[ 83 ] nat_eq (u1, u2) = false => OBJ_eq (C (u1, u3), C (u2, u4)) -> false ;
	[ 84 ] nat_eq (u1, u2) = true /\ nat_eq (u3, u4) = false => OBJ_eq (C (u1, u3), C (u2, u4)) -> false ;
	[ 85 ] nat_eq (0, 0) -> true ;
	[ 86 ] nat_eq (0, S (u1)) -> false ;
	[ 87 ] nat_eq (S (u1), 0) -> false ;
	[ 88 ] nat_eq (S (u1), S (u2)) -> nat_eq (u1, u2) ;
	[ 89 ] memberC (u1, Nil) -> false ;
	[ 90 ] OBJ_eq (u1, u2) = true => memberC (u1, Cons (u2, u3)) -> true ;
	[ 91 ] OBJ_eq (u1, u2) = false => memberC (u1, Cons (u2, u3)) -> memberC (u1, u3) ;
	[ 92 ] memberT (u1, Nil) -> false ;
	[ 93 ] nat_eq (u1, u2) = true => memberT (u1, Cons (C (u2, u3), u4)) -> true ;
	[ 94 ] nat_eq (u1, u2) = false => memberT (u1, Cons (C (u2, u3), u4)) -> memberT (u1, u4) ;
	[ 95 ] memberE (u1, Nil) -> false ;
	[ 96 ] nat_eq (u1, u2) = true => memberE (u1, Cons (C (u3, u2), u4)) -> true ;
	[ 97 ] nat_eq (u1, u2) = false => memberE (u1, Cons (C (u3, u2), u4)) -> memberE (u1, u4) ;
	[ 98 ] timel (Nil) -> 0 ;
	[ 99 ] timel (Cons (u1, u2)) -> time (u1) ;
	[ 100 ] plus (0, u1) -> u1 ;
	[ 101 ] plus (S (u1), u2) -> S (plus (u1, u2)) ;
	[ 102 ] le (0, u1) -> true ;
	[ 103 ] le (S (u1), 0) -> false ;
	[ 104 ] le (S (u1), S (u2)) -> le (u1, u2) ;
	[ 105 ] time (C (u1, u2)) -> u1 ;
	[ 106 ] er (C (u1, u2)) -> u2 ;
	[ 107 ] sortedT (Nil) -> true ;
	[ 108 ] sortedT (Cons (u1, Nil)) -> true ;
	[ 109 ] le (u1, u2) = true => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> sortedT (Cons (C (u1, u4), u5)) ;
	[ 110 ] le (u1, u2) = false => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> false ;
	[ 111 ] sortedE (Nil) -> true ;
	[ 112 ] sortedE (Cons (u1, Nil)) -> true ;
	[ 113 ] le (u1, u2) = true => sortedE (Cons (C (u3, u2), Cons (C (u4, u1), u5))) -> false ;
	[ 114 ] le (u1, u2) = false => sortedE (Cons (C (u3, u2), Cons (C (u4, u1), u5))) -> sortedE (Cons (C (u4, u1), u5)) ;
	[ 115 ] listUpTo (Nil, u1) -> Nil ;
	[ 116 ] le (u1, u2) = true => listUpTo (Cons (C (u1, u3), u4), u2) -> Cons (C (u1, u3), Nil) ;
	[ 117 ] le (u1, u2) = false => listUpTo (Cons (C (u1, u3), u4), u2) -> Cons (C (u1, u3), listUpTo (u4, u2)) ;
	[ 118 ] wind (Nil, u1, u2, u3) -> Nil ;
	[ 119 ] le (plus (u1, u2), u3) = true /\ le (plus (u1, u4), u3) = false => wind (Cons (C (u1, u5), u6), u3, u4, u2) -> Cons (C (u1, u5), wind (u6, u3, u4, u2)) ;
	[ 120 ] le (plus (u1, u2), u3) = false => wind (Cons (C (u1, u4), u5), u3, u6, u2) -> wind (u5, u3, u6, u2) ;
	[ 121 ] le (plus (u1, u2), u3) = true /\ le (plus (u1, u4), u3) = true => wind (Cons (C (u1, u5), u6), u3, u4, u2) -> Cons (C (u1, u5), Nil) ;
	[ 122 ] maxEr (Nil) -> 0 ;
	[ 123 ] le (maxEr (u1), u2) = true => maxEr (Cons (C (u3, u2), u1)) -> u2 ;
	[ 124 ] le (maxEr (u1), u2) = false => maxEr (Cons (C (u3, u2), u1)) -> maxEr (u1) ;
	[ 125 ] sortedT (u1) = true /\ le (u2, u3) = false => acr (u1, u4, u2, u3) -> maxEr (wind (u1, u4, u2, u3)) ;
	[ 126 ] sortedT (u1) = false => acr (u1, u2, u3, u4) -> 0 ;
	[ 127 ] sortedT (u1) = true /\ le (u2, u3) = true => acr (u1, u4, u2, u3) -> 0 ;
	[ 128 ] erl (Nil) -> 0 ;
	[ 129 ] erl (Cons (u1, u2)) -> er (u1) ;
	[ 130 ] insAt (Nil, u1, u2) -> Cons (C (u1, u2), Nil) ;
	[ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
	[ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;
	[ 133 ] insIn (Nil, u1, u2) -> Cons (C (u1, u2), Nil) ;
	[ 134 ] le (er (u1), u2) = true => insIn (Cons (u1, u3), u4, u2) -> insIn (u3, time (u1), u2) ;
	[ 135 ] le (er (u1), u2) = false => insIn (Cons (u1, u3), u4, u2) -> Cons (C (u4, u2), Cons (u1, u3)) ;
	[ 136 ] progAt (Nil, u1) -> 0 ;
	[ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
	[ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;
	[ 139 ] timeAt (Nil, u1) -> 0 ;
	[ 140 ] le (time (u1), u2) = true => timeAt (Cons (u1, u3), u2) -> time (u1) ;
	[ 141 ] le (time (u1), u2) = false => timeAt (Cons (u1, u3), u2) -> timeAt (u3, u2) ;
	[ 142 ] firstAt (Nil, u1) -> C (0, 0) ;
	[ 143 ] le (time (u1), u2) = true => firstAt (Cons (u1, u3), u2) -> u1 ;
	[ 144 ] le (time (u1), u2) = false => firstAt (Cons (u1, u3), u2) -> firstAt (u3, u2) ;
	[ 145 ] listAt (Nil, u1) -> Nil ;
	[ 146 ] le (time (u1), u2) = true => listAt (Cons (u1, u3), u2) -> Cons (u1, u3) ;
	[ 147 ] le (time (u1), u2) = false => listAt (Cons (u1, u3), u2) -> listAt (u3, u2) ;
	[ 148 ] prog (Nil, u1, u2) -> Nil ;
	[ 149 ] le (progAt (prog (u1, u2, u3), plus (time (u4), u3)), er (u4)) = true => prog (Cons (u4, u1), u2, u3) -> insAt (prog (u1, u2, u3), plus (time (u4), u3), er (u4)) ;
	[ 150 ] le (progAt (prog (u1, u2, u3), plus (time (u4), u3)), er (u4)) = false => prog (Cons (u4, u1), u2, u3) -> insIn (prog (u1, u2, u3), plus (time (u4), u2), er (u4)) ;
	[ 151 ] sortedT (u1) = true /\ le (u2, u3) = false => acr1 (u1, u4, u2, u3) -> progAt (prog (u1, u2, u3), u4) ;
	[ 152 ] sortedT (u1) = false => acr1 (u1, u2, u3, u4) -> 0 ;
	[ 153 ] sortedT (u1) = true /\ le (u2, u3) = true => acr1 (u1, u4, u2, u3) -> 0 ;
dico_order:
firstAt: er time le 0 S true false C;
wind: time le plus 0 S true false C Nil Cons;
PLAN_eq: nat_eq OBJ_eq true false;
listAt: er time le 0 S true false C Nil Cons;
memberE: nat_eq true false;
memberT: nat_eq true false;
progAt: er time le 0 S true false C Nil Cons;
timeAt: er time le 0 S true false C;
time: C;
memberC: nat_eq OBJ_eq true false;
OBJ_eq: nat_eq true false;
sortedT: timel time le 0 S true false C Nil Cons;
plus: 0 S;
maxEr: le 0 S true false;
le: 0 S true false;
insAt: time le 0 S true false C Nil Cons;
nat_eq: true false;
er: C;
listUpTo: time le 0 S true false C Nil Cons;
prog: progAt insIn insAt er time le plus 0 S true false C Nil Cons;
acr1: prog progAt insIn insAt sortedT er timel time le plus 0 S true false C Nil Cons;
acr: maxEr wind sortedT timel time le plus 0 S true false C Nil Cons;
Cons: time C;
timel: 0 S;
insIn: er time le 0 S true false C Nil Cons;
erl: er time 0 S C Nil Cons;
sortedE: erl er time le 0 S true false C Nil Cons;
dico_equivalence:
Computing nullary sorts
Sort "nat" is not nullary
Sort "OBJ" is not nullary
Sort "PLAN" is not nullary
Sort "bool" is nullary
Sort "nat" is not nullary
Sort "nat" is not nullary
Sort "OBJ" is not nullary
Computing nullary individuals
We do not have a boolean specification

Successfully parsed properties
Computing default priorities
Using default priorities
Generate will be attempted on the following positions:
Ind_pos_position ()

Successfully parsed strategies

Successfully parsed startpoint

Successfully parsed lemmas
	[ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;

Successfully parsed conjectures
	[ 155 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

Successfully parsed conjectures
	[ 156 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ;

Successfully parsed conjectures
	[ 157 ] sortedT (Cons (u1, u2)) = true => le (timel (u2), time (u1)) = true ;

Successfully parsed startpoint
Closing ../no_rm/progat_insat.spike

Successfully parsed conjectures
	[ 158 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;


************************************************************
******************* Starting computation *******************
************************************************************


dico_st:
fullind = (repeat (stra, inst_var_rule), print_goals_history)
negative_clash_rule = delete(id,[try (negative_clash)])
subsumption_rule = delete(id,[try (subsumption (L&C))])
normalize = repeat try (delete(id,[negative_clash]), simplify(id,[eliminate_redundant_literal]), simplify(id,[eliminate_trivial_literal]), simplify(id,[positive_clash]), simplify(id,[congruence_closure]), simplify(id,[negative_decomposition]), simplify(id,[auto_simplification]), simplify(id,[rewriting (normalize, L&R, *)]), delete(id,[subsumption (L&C)]), simplify(id,[total_case_rewriting (builtin, R, *)]))
augment_rule = simplify(id,[try (augmentation (L))])
stra = repeat (try (tautology_rule, negative_clash_rule, decomposition_rule, rewriting_rule, subsumption_rule, print_goals, total_case_rewriting_add_premise_rule))
inst_var_rule = add_premise(generate,[try (id)])
recursive = try (delete, rewrite, add_premise(id,[generate]))
query = ?
generate_reduce = try (delete(id,[tautology]), rewrite)
rewriting_rule = simplify(id,[try (rewriting (rewrite, L&R&C, *))])
tautology_rule = delete(id,[try (tautology)])
total_case_rewriting_add_premise_rule = add_premise(total_case_rewriting (simplify_strat, R, *),[try (id)])
decompose = saturate (simplify(id,[positive_decomposition]), simplify(id,[negative_decomposition]))
fullind_aug = (repeat (stra_aug, inst_var_rule), print_goals_history)
clean = saturate (simplify(id,[eliminate_redundant_literal]), simplify(id,[eliminate_trivial_literal]), simplify(id,[positive_clash]))
simplify = saturate (delete, clean, decompose, simplify(id,[auto_simplification]))
stra_aug = repeat (try (tautology_rule, negative_clash_rule, decomposition_rule, rewriting_rule, augment_rule, subsumption_rule, print_goals, total_case_rewriting_add_premise_rule))
total_case_rewriting_rule = simplify(id,[try (total_case_rewriting (simplify_strat, R, *))])
rewrite = try (simplify(id,[rewriting (normalize, R, *)]), simplify(id,[equational_rewriting (*)]), simplify(id,[partial_case_rewriting (R&L, *)]))
builtin = try (delete, rewrite, add_premise(id,[generate]))
decomposition_rule = simplify(id,[try (negative_decomposition)])
delete = saturate (delete(id,[tautology]), delete(id,[subsumption (R&L)]), delete(id,[negative_clash]))
Start point is now fullind

************************  Proving  *************************
[ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;


using strategy 

fullind
************************************************************

Current goals E1 (1):
[ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;


GENERATE 1 on
« [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

from the positions:
	false/1/[1] --> le (u1, u2)
	false/2/[1] --> le (u1, u2)
	
at false/1/[1] on 	le (u1, u2) 	 using the test substitutions:

 1) <! u1, 0 !>
 2) <! u2, 0 ; u1, S (u3) !>
 3) <! u2, S (u4) ; u1, S (u3) !>

We obtain :

1) [ 175 ] true = false /\ le (0, u2) = true =>  ;

using the rule [ 102 ] le (0, u1) -> true ;
2) [ 181 ] false = false /\ le (S (u3), 0) = true =>  ;

using the rule [ 103 ] le (S (u1), 0) -> false ;
3) [ 187 ] le (u3, u4) = false /\ le (S (u3), S (u4)) = true =>  ;

using the rule [ 104 ] le (S (u1), S (u2)) -> le (u1, u2) ;


NEGATIVE CLASH: delete
« [ 175 ] true = false /\ le (0, u2) = true =>  ;

NEGATIVE DECOMPOSITION : simplify
« [ 181 ] false = false /\ le (S (u3), 0) = true =>  ;

» [ 188 ] le (S (u3), 0) = true =>  ;


REWRITING 1: simplify by rewriting 
« [ 187 ] le (u3, u4) = false /\ le (S (u3), S (u4)) = true =>  ;


- rewriting at the position false/2/[1]:

le (S (u3), S (u4))
   is simplified by : le (S (u1), S (u2)) -> le (u1, u2)   (from [ 104 ] of R)
   with substitution: <! u1, u3 ; u2, u4 !> into
le (u3, u4)


» [ 191 ] le (u3, u4) = false /\ le (u3, u4) = true =>  ;


REWRITING 2: simplify by rewriting 
« [ 188 ] le (S (u3), 0) = true =>  ;


- rewriting at the position false/1/[1]:

le (S (u3), 0)
   is simplified by : le (S (u1), 0) -> false   (from [ 103 ] of R)
   with substitution: <! u1, u3 !> into
false


» [ 194 ] false = true =>  ;


NEGATIVE CLASH: delete
« [ 194 ] false = true =>  ;


SUBSUMPTION: delete
« [ 191 ] le (u3, u4) = false /\ le (u3, u4) = true =>  ;

Subsumed in C1 by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u3 ; u2, u4 !>



The following initial conjectures are inductive consequences of R

[ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;


(* Generating the COQ proof of the conjectures:

  forall u1 u2, (le u1 u2) = false -> (le u1 u2) = true -> False

*)
Elapsed time: 0.040434 s

--- Global statistics of the main successful operations ---

- tautology               : 0 of 13 tries.
- rewriting               : 2 of 4 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 1 of 2 tries.
- total_case_rewriting    : 0 of 1 tries.
- generate                : 1 of 1 tries.

-----------
  Total clauses: 198

-----------
  Total lemmas: 1

  Max depth    : 1

************************  Proving  *************************
[ 199 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;
[ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;


using strategy 

fullind
************************************************************

Current goals E2 (1):
[ 199 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ;


GENERATE 2 on
« [ 199 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ;

from the positions:
	false/1/[1] --> sortedT (Cons (u1, u2))
	
at false/1/[1] on 	sortedT (Cons (u1, u2)) 	 using the test substitutions:

 1) <! u2, Nil !>
 2) <! u2, Cons (C (u3, u6), u7) ; u1, C (u4, u5) !>
 3) <! u2, Cons (C (u3, u6), u7) ; u1, C (u4, u5) !>

We obtain :

1) [ 214 ] true = true => sortedT (Nil) = true ;

using the rule [ 108 ] sortedT (Cons (u1, Nil)) -> true ;
2) [ 220 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => sortedT (Cons (C (u3, u6), u7)) = true ;

using the rule [ 109 ] le (u1, u2) = true => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> sortedT (Cons (C (u1, u4), u5)) ;
3) [ 226 ] false = true /\ le (u3, u4) = false => sortedT (Cons (C (u3, u6), u7)) = true ;

using the rule [ 110 ] le (u1, u2) = false => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> false ;

TAUTOLOGY: delete
« [ 220 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => sortedT (Cons (C (u3, u6), u7)) = true ;


NEGATIVE CLASH: delete
« [ 226 ] false = true /\ le (u3, u4) = false => sortedT (Cons (C (u3, u6), u7)) = true ;

NEGATIVE DECOMPOSITION : simplify
« [ 214 ] true = true => sortedT (Nil) = true ;

» [ 227 ] sortedT (Nil) = true ;


REWRITING 3: simplify by rewriting 
« [ 227 ] sortedT (Nil) = true ;


- rewriting at the position true/1/[1]:

sortedT (Nil)
   is simplified by : sortedT (Nil) -> true   (from [ 107 ] of R)
   with substitution: <!  !> into
true


» [ 230 ] true = true ;

TAUTOLOGY: delete
« [ 230 ] true = true ;



The following initial conjectures are inductive consequences of R

[ 199 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ;


(* Generating the COQ proof of the conjectures:

  forall u1 u2, (sortedT (Cons u1 u2)) = true -> (sortedT u2) = true

*)
Elapsed time: 0.04369 s

--- Global statistics of the main successful operations ---

- tautology               : 2 of 21 tries.
- rewriting               : 3 of 6 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 1 of 3 tries.
- total_case_rewriting    : 0 of 2 tries.
- generate                : 2 of 2 tries.

-----------
  Total clauses: 230

-----------
  Total lemmas: 2

  Max depth    : 1

************************  Proving  *************************
[ 231 ] sortedT (Cons (u1, u2)) = true => le (timel (u2), time (u1)) = true ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;
[ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;
[ 199 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ;


using strategy 

fullind
************************************************************

Current goals E3 (1):
[ 231 ] sortedT (Cons (u1, u2)) = true => le (timel (u2), time (u1)) = true ;


GENERATE 3 on
« [ 231 ] sortedT (Cons (u1, u2)) = true => le (timel (u2), time (u1)) = true ;

from the positions:
	false/1/[1] --> sortedT (Cons (u1, u2))
	
at false/1/[1] on 	sortedT (Cons (u1, u2)) 	 using the test substitutions:

 1) <! u2, Nil !>
 2) <! u2, Cons (C (u3, u6), u7) ; u1, C (u4, u5) !>
 3) <! u2, Cons (C (u3, u6), u7) ; u1, C (u4, u5) !>

We obtain :

1) [ 247 ] true = true => le (timel (Nil), time (u1)) = true ;

using the rule [ 108 ] sortedT (Cons (u1, Nil)) -> true ;
2) [ 253 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (timel (Cons (C (u3, u6), u7)), time (C (u4, u5))) = true ;

using the rule [ 109 ] le (u1, u2) = true => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> sortedT (Cons (C (u1, u4), u5)) ;
3) [ 259 ] false = true /\ le (u3, u4) = false => le (timel (Cons (C (u3, u6), u7)), time (C (u4, u5))) = true ;

using the rule [ 110 ] le (u1, u2) = false => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> false ;


NEGATIVE CLASH: delete
« [ 259 ] false = true /\ le (u3, u4) = false => le (timel (Cons (C (u3, u6), u7)), time (C (u4, u5))) = true ;

NEGATIVE DECOMPOSITION : simplify
« [ 247 ] true = true => le (timel (Nil), time (u1)) = true ;

» [ 260 ] le (timel (Nil), time (u1)) = true ;


REWRITING 4: simplify by rewriting 
« [ 253 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (timel (Cons (C (u3, u6), u7)), time (C (u4, u5))) = true ;


- rewriting at the position true/1/[1-2]:

time (C (u4, u5))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u4 ; u2, u5 !> into
u4


» [ 263 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (timel (Cons (C (u3, u6), u7)), u4) = true ;


REWRITING 5: simplify by rewriting 
« [ 260 ] le (timel (Nil), time (u1)) = true ;


- rewriting at the position true/1/[1-1]:

timel (Nil)
   is simplified by : timel (Nil) -> 0   (from [ 98 ] of R)
   with substitution: <!  !> into
0


» [ 266 ] le (0, time (u1)) = true ;


REWRITING 6: simplify by rewriting 
« [ 263 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (timel (Cons (C (u3, u6), u7)), u4) = true ;


- rewriting at the position true/1/[1-1]:

timel (Cons (C (u3, u6), u7))
   is simplified by : timel (Cons (u1, u2)) -> time (u1)   (from [ 99 ] of R)
   with substitution: <! u1, C (u3, u6) ; u2, u7 !> into
time (C (u3, u6))


» [ 269 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (time (C (u3, u6)), u4) = true ;


REWRITING 7: simplify by rewriting 
« [ 266 ] le (0, time (u1)) = true ;


- rewriting at the position true/1/[1]:

le (0, time (u1))
   is simplified by : le (0, u1) -> true   (from [ 102 ] of R)
   with substitution: <! u1, time (u1) !> into
true


» [ 272 ] true = true ;

TAUTOLOGY: delete
« [ 272 ] true = true ;


REWRITING 8: simplify by rewriting 
« [ 269 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (time (C (u3, u6)), u4) = true ;


- rewriting at the position true/1/[1-1]:

time (C (u3, u6))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u3 ; u2, u6 !> into
u3


» [ 275 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (u3, u4) = true ;

TAUTOLOGY: delete
« [ 275 ] sortedT (Cons (C (u3, u6), u7)) = true /\ le (u3, u4) = true => le (u3, u4) = true ;



The following initial conjectures are inductive consequences of R

[ 231 ] sortedT (Cons (u1, u2)) = true => le (timel (u2), time (u1)) = true ;


(* Generating the COQ proof of the conjectures:

  forall u1 u2, (sortedT (Cons u1 u2)) = true -> (le (timel u2) (time u1)) = true

*)
Elapsed time: 0.04832 s

--- Global statistics of the main successful operations ---

- tautology               : 4 of 39 tries.
- rewriting               : 8 of 12 tries.
- augmentation            : 0 of 0 tries.
- subsumption             : 1 of 4 tries.
- total_case_rewriting    : 0 of 3 tries.
- generate                : 3 of 3 tries.

-----------
  Total clauses: 275

-----------
  Total lemmas: 3

  Max depth    : 1
Start point is now fullind_aug

************************  Proving  *************************
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using lemmas

[ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;
[ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;
[ 199 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ;
[ 231 ] sortedT (Cons (u1, u2)) = true => le (timel (u2), time (u1)) = true ;


using strategy 

fullind_aug
************************************************************

Current goals E4 (1):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;


GENERATE 4 on
« [ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;

from the positions:
	false/1/[1] --> sortedT (u1)
	true/1/[1] --> progAt (insAt (u1, u2, u4), u3)
	true/1/[1-1] --> insAt (u1, u2, u4)
	
at false/1/[1] on 	sortedT (u1) 	 using the test substitutions:

 1) <! u1, Nil !>
 2) <! u1, Cons (C (u6, u7), Nil) !>
 3) <! u1, Cons (C (u6, u7), Cons (C (u5, u8), u9)) !>
 4) <! u1, Cons (C (u6, u7), Cons (C (u5, u8), u9)) !>

We obtain :

1) [ 310 ] true = true /\ le (u2, u3) = false => progAt (insAt (Nil, u2, u4), u3) = progAt (Nil, u3) ;

using the rule [ 107 ] sortedT (Nil) -> true ;
2) [ 316 ] true = true /\ le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;

using the rule [ 108 ] sortedT (Cons (u1, Nil)) -> true ;
3) [ 322 ] sortedT (Cons (C (u5, u8), u9)) = true /\ le (u2, u3) = false /\ le (u5, u6) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

using the rule [ 109 ] le (u1, u2) = true => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> sortedT (Cons (C (u1, u4), u5)) ;
4) [ 328 ] false = true /\ le (u2, u3) = false /\ le (u5, u6) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

using the rule [ 110 ] le (u1, u2) = false => sortedT (Cons (C (u2, u3), Cons (C (u1, u4), u5))) -> false ;


NEGATIVE CLASH: delete
« [ 328 ] false = true /\ le (u2, u3) = false /\ le (u5, u6) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

NEGATIVE DECOMPOSITION : simplify
« [ 310 ] true = true /\ le (u2, u3) = false => progAt (insAt (Nil, u2, u4), u3) = progAt (Nil, u3) ;

» [ 329 ] le (u2, u3) = false => progAt (insAt (Nil, u2, u4), u3) = progAt (Nil, u3) ;

NEGATIVE DECOMPOSITION : simplify
« [ 316 ] true = true /\ le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;

» [ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;


REWRITING 9: simplify by rewriting 
« [ 329 ] le (u2, u3) = false => progAt (insAt (Nil, u2, u4), u3) = progAt (Nil, u3) ;


- rewriting at the position true/1/[2]:

progAt (Nil, u3)
   is simplified by : progAt (Nil, u1) -> 0   (from [ 136 ] of R)
   with substitution: <! u1, u3 !> into
0


» [ 333 ] le (u2, u3) = false => progAt (insAt (Nil, u2, u4), u3) = 0 ;


REWRITING 10: simplify by rewriting 
« [ 333 ] le (u2, u3) = false => progAt (insAt (Nil, u2, u4), u3) = 0 ;


- rewriting at the position true/1/[1-1]:

insAt (Nil, u2, u4)
   is simplified by : insAt (Nil, u1, u2) -> Cons (C (u1, u2), Nil)   (from [ 130 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
Cons (C (u2, u4), Nil)


» [ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;


AUGMENTATION: simplify
« [ 322 ] sortedT (Cons (C (u5, u8), u9)) = true /\ le (u2, u3) = false /\ le (u5, u6) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

	 Success with [ 199 ] sortedT (Cons (u1, u2)) = true => sortedT (u2) = true ; from L
	 Success with [ 231 ] sortedT (Cons (u1, u2)) = true => le (timel (u2), time (u1)) = true ; from L

» [ 375 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), time (C (u5, u8))) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

REWRITING 11: simplify by rewriting 
« [ 375 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), time (C (u5, u8))) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;


- rewriting at the position false/4/[1-2]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;


Current goals E5 (3):
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

Current premises H5 (1):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;

TOTAL CASE REWRITING 1: simplify clause
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Nil), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 438 ] le (u2, u3) = false /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = 0 ;

using [ 137 ] from R

» 2) [ 442 ] le (u2, u3) = false /\ le (time (C (u2, u4)), u3) = false => progAt (Nil, u3) = 0 ;

using [ 138 ] from R



REWRITING 12: simplify by rewriting 
« [ 438 ] le (u2, u3) = false /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = 0 ;


- rewriting at the position false/2/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 445 ] le (u2, u3) = false /\ le (u2, u3) = true => er (C (u2, u4)) = 0 ;


REWRITING 13: simplify by rewriting 
« [ 442 ] le (u2, u3) = false /\ le (time (C (u2, u4)), u3) = false => progAt (Nil, u3) = 0 ;


- rewriting at the position true/1/[1]:

progAt (Nil, u3)
   is simplified by : progAt (Nil, u1) -> 0   (from [ 136 ] of R)
   with substitution: <! u1, u3 !> into
0


» [ 448 ] le (u2, u3) = false /\ le (time (C (u2, u4)), u3) = false => 0 = 0 ;

TAUTOLOGY: delete
« [ 448 ] le (u2, u3) = false /\ le (time (C (u2, u4)), u3) = false => 0 = 0 ;


REWRITING 14: simplify by rewriting 
« [ 445 ] le (u2, u3) = false /\ le (u2, u3) = true => er (C (u2, u4)) = 0 ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 451 ] le (u2, u3) = false /\ le (u2, u3) = true => u4 = 0 ;


SUBSUMPTION: delete
« [ 451 ] le (u2, u3) = false /\ le (u2, u3) = true => u4 = 0 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E6 (2):
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

Current premises H6 (2):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;

TOTAL CASE REWRITING 2: simplify clause
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;

at position true/1/[2] on 	progAt (Cons (C (u6, u7), Nil), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 495 ] le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = er (C (u6, u7)) ;

using [ 137 ] from R

» 2) [ 499 ] le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Nil, u3) ;

using [ 138 ] from R



REWRITING 15: simplify by rewriting 
« [ 495 ] le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = er (C (u6, u7)) ;


- rewriting at the position false/2/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 502 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = er (C (u6, u7)) ;


REWRITING 16: simplify by rewriting 
« [ 499 ] le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Nil, u3) ;


- rewriting at the position true/1/[2]:

progAt (Nil, u3)
   is simplified by : progAt (Nil, u1) -> 0   (from [ 136 ] of R)
   with substitution: <! u1, u3 !> into
0


» [ 505 ] le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;


REWRITING 17: simplify by rewriting 
« [ 502 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = er (C (u6, u7)) ;


- rewriting at the position true/1/[2]:

er (C (u6, u7))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u7


» [ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;


REWRITING 18: simplify by rewriting 
« [ 505 ] le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;


- rewriting at the position false/2/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;


Current goals E7 (3):
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;

Current premises H7 (3):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;

TOTAL CASE REWRITING 3: simplify clause
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

at position true/1/[2] on 	progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 569 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (time (C (u6, u7)), u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u6, u7)) ;

using [ 137 ] from R

» 2) [ 573 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (time (C (u6, u7)), u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;

using [ 138 ] from R



REWRITING 19: simplify by rewriting 
« [ 569 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (time (C (u6, u7)), u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u6, u7)) ;


- rewriting at the position false/5/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 576 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u6, u7)) ;


REWRITING 20: simplify by rewriting 
« [ 573 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (time (C (u6, u7)), u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;


- rewriting at the position false/5/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;


REWRITING 21: simplify by rewriting 
« [ 576 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u6, u7)) ;


- rewriting at the position true/1/[2]:

er (C (u6, u7))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u7


» [ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;


Current goals E8 (4):
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;

Current premises H8 (4):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;

TOTAL CASE REWRITING 4: simplify clause
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;

at position true/1/[2] on 	progAt (Cons (C (u5, u8), u9), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 648 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u5, u8)) ;

using [ 137 ] from R

» 2) [ 652 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;

using [ 138 ] from R



REWRITING 22: simplify by rewriting 
« [ 648 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u5, u8)) ;


- rewriting at the position false/6/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 655 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u5, u8)) ;


REWRITING 23: simplify by rewriting 
« [ 652 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;


- rewriting at the position false/6/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;


REWRITING 24: simplify by rewriting 
« [ 655 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = er (C (u5, u8)) ;


- rewriting at the position true/1/[2]:

er (C (u5, u8))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u8


» [ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;


Current goals E9 (5):
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;

Current premises H9 (5):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;

TOTAL CASE REWRITING 5: simplify clause
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;

at position true/1/[1-1] on 	insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4)


 The current clause is added to H since the new conjectures are smaller : 

« [ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;

with the rules 

1) [ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
2) [ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;

resulting

» 1) [ 733 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;

using [ 131 ] from R

» 2) [ 737 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;

using [ 132 ] from R



REWRITING 25: simplify by rewriting 
« [ 733 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;


- rewriting at the position false/7/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;


REWRITING 26: simplify by rewriting 
« [ 737 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;


- rewriting at the position false/7/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;


Current goals E10 (6):
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;

Current premises H10 (6):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;

TOTAL CASE REWRITING 6: simplify clause
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;

at position true/1/[1-1] on 	insAt (Cons (C (u6, u7), Nil), u2, u4)


 The current clause is added to H since the new conjectures are smaller : 

« [ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;

with the rules 

1) [ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
2) [ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;

resulting

» 1) [ 817 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;

using [ 131 ] from R

» 2) [ 821 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Nil, u2, u4), u3) = u7 ;

using [ 132 ] from R



REWRITING 27: simplify by rewriting 
« [ 817 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;


- rewriting at the position false/3/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;


REWRITING 28: simplify by rewriting 
« [ 821 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Nil, u2, u4), u3) = u7 ;


- rewriting at the position true/1/[1-1]:

insAt (Nil, u2, u4)
   is simplified by : insAt (Nil, u1, u2) -> Cons (C (u1, u2), Nil)   (from [ 130 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
Cons (C (u2, u4), Nil)


» [ 827 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = u7 ;


REWRITING 29: simplify by rewriting 
« [ 827 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = u7 ;


- rewriting at the position false/3/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 830 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = u7 ;


SUBSUMPTION: delete
« [ 830 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = u7 ;

Subsumed in L by [ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;

	with epsilon = <! u1, u6 ; u2, u3 ; u3, u2 !>


Current goals E11 (6):
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;

Current premises H11 (7):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;

TOTAL CASE REWRITING 7: simplify clause
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;

at position true/1/[1-1] on 	insAt (Cons (C (u6, u7), Nil), u2, u4)


 The current clause is added to H since the new conjectures are smaller : 

« [ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;

with the rules 

1) [ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
2) [ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;

resulting

» 1) [ 926 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;

using [ 131 ] from R

» 2) [ 930 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Nil, u2, u4), u3) = 0 ;

using [ 132 ] from R



REWRITING 30: simplify by rewriting 
« [ 926 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;


- rewriting at the position false/3/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;


REWRITING 31: simplify by rewriting 
« [ 930 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Nil, u2, u4), u3) = 0 ;


- rewriting at the position true/1/[1-1]:

insAt (Nil, u2, u4)
   is simplified by : insAt (Nil, u1, u2) -> Cons (C (u1, u2), Nil)   (from [ 130 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
Cons (C (u2, u4), Nil)


» [ 936 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u6, u7)), u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;


REWRITING 32: simplify by rewriting 
« [ 936 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u6, u7)), u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;


- rewriting at the position false/3/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 939 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;


SUBSUMPTION: delete
« [ 939 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;

Subsumed in C1 by [ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;

	with epsilon = <! u2, u2 ; u3, u3 ; u4, u4 !>


Current goals E12 (6):
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;

Current premises H12 (8):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;

TOTAL CASE REWRITING 8: simplify clause
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;

at position true/1/[1-1] on 	insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4)


 The current clause is added to H since the new conjectures are smaller : 

« [ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;

with the rules 

1) [ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
2) [ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;

resulting

» 1) [ 1039 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;

using [ 131 ] from R

» 2) [ 1043 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u7 ;

using [ 132 ] from R



REWRITING 33: simplify by rewriting 
« [ 1039 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;


- rewriting at the position false/6/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;


REWRITING 34: simplify by rewriting 
« [ 1043 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u7 ;


- rewriting at the position false/6/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1049 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u7 ;


SUBSUMPTION: delete
« [ 1049 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u7 ;

Subsumed in L by [ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;

	with epsilon = <! u1, u6 ; u2, u3 ; u3, u2 !>


Current goals E13 (6):
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;

Current premises H13 (9):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;

TOTAL CASE REWRITING 9: simplify clause
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;

at position true/1/[1-1] on 	insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4)


 The current clause is added to H since the new conjectures are smaller : 

« [ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;

with the rules 

1) [ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
2) [ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;

resulting

» 1) [ 1150 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;

using [ 131 ] from R

» 2) [ 1154 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

using [ 132 ] from R



REWRITING 35: simplify by rewriting 
« [ 1150 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (time (C (u6, u7)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;


- rewriting at the position false/7/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;


REWRITING 36: simplify by rewriting 
« [ 1154 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (time (C (u6, u7)), u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;


- rewriting at the position false/7/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;


Current goals E14 (7):
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

Current premises H14 (10):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;

TOTAL CASE REWRITING 10: simplify clause
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 1248 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;

using [ 137 ] from R

» 2) [ 1252 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

using [ 138 ] from R



REWRITING 37: simplify by rewriting 
« [ 1248 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;


- rewriting at the position false/8/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 1255 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;


REWRITING 38: simplify by rewriting 
« [ 1252 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;


- rewriting at the position false/8/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;


REWRITING 39: simplify by rewriting 
« [ 1255 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 1261 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = progAt (u9, u3) ;


SUBSUMPTION: delete
« [ 1261 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = progAt (u9, u3) ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E15 (7):
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

Current premises H15 (11):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;

TOTAL CASE REWRITING 11: simplify clause
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

at position true/1/[1] on 	progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 1371 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = progAt (u9, u3) ;

using [ 137 ] from R

» 2) [ 1375 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

using [ 138 ] from R



REWRITING 40: simplify by rewriting 
« [ 1371 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = progAt (u9, u3) ;


- rewriting at the position false/9/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = progAt (u9, u3) ;


REWRITING 41: simplify by rewriting 
« [ 1375 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;


- rewriting at the position false/9/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;


REWRITING 42: simplify by rewriting 
« [ 1378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = progAt (u9, u3) ;


- rewriting at the position true/1/[1]:

er (C (u6, u7))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u7


» [ 1384 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = progAt (u9, u3) ;


SUBSUMPTION: delete
« [ 1384 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = progAt (u9, u3) ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u6 ; u2, u3 !>


Current goals E16 (7):
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

Current premises H16 (12):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

TOTAL CASE REWRITING 12: simplify clause
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

at position true/1/[1] on 	progAt (Cons (C (u5, u8), u9), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 1494 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;

using [ 137 ] from R

» 2) [ 1498 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = progAt (u9, u3) ;

using [ 138 ] from R


TAUTOLOGY: delete
« [ 1498 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = progAt (u9, u3) ;


REWRITING 43: simplify by rewriting 
« [ 1494 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;


- rewriting at the position false/10/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 1501 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;


REWRITING 44: simplify by rewriting 
« [ 1501 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;


- rewriting at the position true/1/[1]:

er (C (u5, u8))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u8


» [ 1504 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => u8 = progAt (u9, u3) ;


SUBSUMPTION: delete
« [ 1504 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => u8 = progAt (u9, u3) ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u5 ; u2, u3 !>


Current goals E17 (6):
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

Current premises H17 (13):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

TOTAL CASE REWRITING 13: simplify clause
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;

at position true/1/[1-1] on 	insAt (Cons (C (u5, u8), u9), u2, u4)


 The current clause is added to H since the new conjectures are smaller : 

« [ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;

with the rules 

1) [ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
2) [ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;

resulting

» 1) [ 1580 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

using [ 131 ] from R

» 2) [ 1584 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = false => progAt (insAt (u9, u2, u4), u3) = progAt (u9, u3) ;

using [ 132 ] from R



REWRITING 45: simplify by rewriting 
« [ 1580 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;


- rewriting at the position false/8/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;


REWRITING 46: simplify by rewriting 
« [ 1584 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = false => progAt (insAt (u9, u2, u4), u3) = progAt (u9, u3) ;


- rewriting at the position false/8/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 1590 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = false => progAt (insAt (u9, u2, u4), u3) = progAt (u9, u3) ;


SUBSUMPTION: delete
« [ 1590 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = false => progAt (insAt (u9, u2, u4), u3) = progAt (u9, u3) ;

Subsumed in C1 by [ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;

	with epsilon = <! u1, u9 ; u2, u2 ; u3, u3 ; u4, u4 !>


Current goals E18 (6):
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H18 (14):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;

TOTAL CASE REWRITING 14: simplify clause
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 1693 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u7 ;

using [ 137 ] from R

» 2) [ 1697 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;

using [ 138 ] from R



REWRITING 47: simplify by rewriting 
« [ 1693 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u7 ;


- rewriting at the position false/4/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 1700 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u7 ;


REWRITING 48: simplify by rewriting 
« [ 1697 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;


- rewriting at the position false/4/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;


REWRITING 49: simplify by rewriting 
« [ 1700 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u7 ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 1706 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = u7 ;


SUBSUMPTION: delete
« [ 1706 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = u7 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E19 (6):
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H19 (15):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;

TOTAL CASE REWRITING 15: simplify clause
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;

at position true/1/[1] on 	progAt (Cons (C (u6, u7), Nil), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 1809 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = u7 ;

using [ 137 ] from R

» 2) [ 1813 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Nil, u3) = u7 ;

using [ 138 ] from R



REWRITING 50: simplify by rewriting 
« [ 1809 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = u7 ;


- rewriting at the position false/5/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1816 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = u7 ;


REWRITING 51: simplify by rewriting 
« [ 1813 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Nil, u3) = u7 ;


- rewriting at the position true/1/[1]:

progAt (Nil, u3)
   is simplified by : progAt (Nil, u1) -> 0   (from [ 136 ] of R)
   with substitution: <! u1, u3 !> into
0


» [ 1819 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => 0 = u7 ;


REWRITING 52: simplify by rewriting 
« [ 1816 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = u7 ;


- rewriting at the position true/1/[1]:

er (C (u6, u7))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u7


» [ 1822 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = u7 ;

TAUTOLOGY: delete
« [ 1822 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = u7 ;


REWRITING 53: simplify by rewriting 
« [ 1819 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => 0 = u7 ;


- rewriting at the position false/5/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 1825 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => 0 = u7 ;


SUBSUMPTION: delete
« [ 1825 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => 0 = u7 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u6 ; u2, u3 !>


Current goals E20 (5):
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H20 (16):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;

TOTAL CASE REWRITING 16: simplify clause
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 1893 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = 0 ;

using [ 137 ] from R

» 2) [ 1897 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = 0 ;

using [ 138 ] from R



REWRITING 54: simplify by rewriting 
« [ 1893 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = 0 ;


- rewriting at the position false/4/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 1900 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = 0 ;


REWRITING 55: simplify by rewriting 
« [ 1897 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = 0 ;


- rewriting at the position false/4/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 1903 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = 0 ;


REWRITING 56: simplify by rewriting 
« [ 1900 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = 0 ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 1906 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = 0 ;


SUBSUMPTION: delete
« [ 1903 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = 0 ;

Subsumed in C1 by [ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;

	with epsilon = <! u2, u6 ; u3, u3 ; u4, u7 !>


SUBSUMPTION: delete
« [ 1906 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = 0 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E21 (4):
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H21 (17):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;

TOTAL CASE REWRITING 17: simplify clause
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2010 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u7 ;

using [ 137 ] from R

» 2) [ 2014 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;

using [ 138 ] from R



REWRITING 57: simplify by rewriting 
« [ 2010 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u7 ;


- rewriting at the position false/7/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2017 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u7 ;


REWRITING 58: simplify by rewriting 
« [ 2014 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;


- rewriting at the position false/7/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;


REWRITING 59: simplify by rewriting 
« [ 2017 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u7 ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 2023 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = u7 ;


SUBSUMPTION: delete
« [ 2023 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = u7 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E22 (4):
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H22 (18):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;

TOTAL CASE REWRITING 18: simplify clause
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;

at position true/1/[1] on 	progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2113 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = u7 ;

using [ 137 ] from R

» 2) [ 2117 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u7 ;

using [ 138 ] from R



REWRITING 60: simplify by rewriting 
« [ 2113 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = u7 ;


- rewriting at the position false/8/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 2120 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = u7 ;


REWRITING 61: simplify by rewriting 
« [ 2117 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u7 ;


- rewriting at the position false/8/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 2123 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u7 ;


REWRITING 62: simplify by rewriting 
« [ 2120 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = u7 ;


- rewriting at the position true/1/[1]:

er (C (u6, u7))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u7


» [ 2126 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = u7 ;

TAUTOLOGY: delete
« [ 2126 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = u7 ;


SUBSUMPTION: delete
« [ 2123 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u7 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u6 ; u2, u3 !>


Current goals E23 (3):
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H23 (19):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;

TOTAL CASE REWRITING 19: simplify clause
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2178 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u8 ;

using [ 137 ] from R

» 2) [ 2182 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;

using [ 138 ] from R



REWRITING 63: simplify by rewriting 
« [ 2178 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u8 ;


- rewriting at the position false/8/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2185 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u8 ;


REWRITING 64: simplify by rewriting 
« [ 2182 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;


- rewriting at the position false/8/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;


REWRITING 65: simplify by rewriting 
« [ 2185 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u8 ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 2191 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = u8 ;


SUBSUMPTION: delete
« [ 2191 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = true => u4 = u8 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E24 (3):
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H24 (20):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;

TOTAL CASE REWRITING 20: simplify clause
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;

at position true/1/[1] on 	progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2274 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = u8 ;

using [ 137 ] from R

» 2) [ 2278 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

using [ 138 ] from R



REWRITING 66: simplify by rewriting 
« [ 2274 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = true => er (C (u6, u7)) = u8 ;


- rewriting at the position false/9/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 2281 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = u8 ;


REWRITING 67: simplify by rewriting 
« [ 2278 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (time (C (u6, u7)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;


- rewriting at the position false/9/[1-1]:

time (C (u6, u7))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u6


» [ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;


REWRITING 68: simplify by rewriting 
« [ 2281 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => er (C (u6, u7)) = u8 ;


- rewriting at the position true/1/[1]:

er (C (u6, u7))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u6 ; u2, u7 !> into
u7


» [ 2287 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = u8 ;


SUBSUMPTION: delete
« [ 2287 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = true => u7 = u8 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u6 ; u2, u3 !>


Current goals E25 (3):
[ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H25 (21):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;

TOTAL CASE REWRITING 21: simplify clause
[ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

at position true/1/[1] on 	progAt (Cons (C (u5, u8), u9), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2368 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = u8 ;

using [ 137 ] from R

» 2) [ 2372 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = u8 ;

using [ 138 ] from R



REWRITING 69: simplify by rewriting 
« [ 2368 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = u8 ;


- rewriting at the position false/10/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 2375 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = u8 ;


REWRITING 70: simplify by rewriting 
« [ 2372 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = u8 ;


- rewriting at the position false/10/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 2378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (u9, u3) = u8 ;


REWRITING 71: simplify by rewriting 
« [ 2375 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = u8 ;


- rewriting at the position true/1/[1]:

er (C (u5, u8))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u8


» [ 2381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => u8 = u8 ;

TAUTOLOGY: delete
« [ 2381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = true => u8 = u8 ;


SUBSUMPTION: delete
« [ 2378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (u9, u3) = u8 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u5 ; u2, u3 !>


Current goals E26 (2):
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

Current premises H26 (22):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;
[ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

TOTAL CASE REWRITING 22: simplify clause
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

at position true/1/[1-1] on 	insAt (Cons (C (u5, u8), u9), u2, u4)


 The current clause is added to H since the new conjectures are smaller : 

« [ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

with the rules 

1) [ 131 ] le (time (u1), u2) = true => insAt (Cons (u1, u3), u2, u4) -> Cons (C (u2, u4), Cons (u1, u3)) ;
2) [ 132 ] le (time (u1), u2) = false => insAt (Cons (u1, u3), u2, u4) -> insAt (u3, u2, u4) ;

resulting

» 1) [ 2425 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;

using [ 131 ] from R

» 2) [ 2429 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = false => progAt (insAt (u9, u2, u4), u3) = u8 ;

using [ 132 ] from R



REWRITING 72: simplify by rewriting 
« [ 2425 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;


- rewriting at the position false/8/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 2432 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;


REWRITING 73: simplify by rewriting 
« [ 2429 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (time (C (u5, u8)), u2) = false => progAt (insAt (u9, u2, u4), u3) = u8 ;


- rewriting at the position false/8/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 2435 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = false => progAt (insAt (u9, u2, u4), u3) = u8 ;


SUBSUMPTION: delete
« [ 2435 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = false => progAt (insAt (u9, u2, u4), u3) = u8 ;

Subsumed in L by [ 154 ] le (u1, u2) = true /\ le (u1, u3) = false /\ le (u3, u2) = false =>  ;

	with epsilon = <! u1, u5 ; u2, u3 ; u3, u2 !>


Current goals E27 (2):
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 2432 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;

Current premises H27 (23):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;
[ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;

TOTAL CASE REWRITING 23: simplify clause
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2509 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;

using [ 137 ] from R

» 2) [ 2513 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

using [ 138 ] from R



REWRITING 74: simplify by rewriting 
« [ 2509 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;


- rewriting at the position false/9/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2516 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;


REWRITING 75: simplify by rewriting 
« [ 2513 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;


- rewriting at the position false/9/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2519 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;


REWRITING 76: simplify by rewriting 
« [ 2516 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = progAt (u9, u3) ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 2522 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => u4 = progAt (u9, u3) ;


SUBSUMPTION: delete
« [ 2522 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => u4 = progAt (u9, u3) ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E28 (2):
[ 2519 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 2432 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;

Current premises H28 (24):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;
[ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;

TOTAL CASE REWRITING 24: simplify clause
[ 2519 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

at position true/1/[1] on 	progAt (Cons (C (u5, u8), u9), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 2519 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2596 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;

using [ 137 ] from R

» 2) [ 2600 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = progAt (u9, u3) ;

using [ 138 ] from R


TAUTOLOGY: delete
« [ 2600 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = progAt (u9, u3) ;


REWRITING 77: simplify by rewriting 
« [ 2596 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;


- rewriting at the position false/10/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 2603 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;


REWRITING 78: simplify by rewriting 
« [ 2603 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = progAt (u9, u3) ;


- rewriting at the position true/1/[1]:

er (C (u5, u8))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u8


» [ 2606 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => u8 = progAt (u9, u3) ;


SUBSUMPTION: delete
« [ 2606 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => u8 = progAt (u9, u3) ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u5 ; u2, u3 !>


Current goals E29 (1):
[ 2432 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;

Current premises H29 (25):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;
[ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 2519 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;

TOTAL CASE REWRITING 25: simplify clause
[ 2432 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;

at position true/1/[1] on 	progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 2432 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2642 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u8 ;

using [ 137 ] from R

» 2) [ 2646 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

using [ 138 ] from R



REWRITING 79: simplify by rewriting 
« [ 2642 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = true => er (C (u2, u4)) = u8 ;


- rewriting at the position false/9/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2649 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u8 ;


REWRITING 80: simplify by rewriting 
« [ 2646 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (time (C (u2, u4)), u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;


- rewriting at the position false/9/[1-1]:

time (C (u2, u4))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u2


» [ 2652 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;


REWRITING 81: simplify by rewriting 
« [ 2649 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => er (C (u2, u4)) = u8 ;


- rewriting at the position true/1/[1]:

er (C (u2, u4))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u2 ; u2, u4 !> into
u4


» [ 2655 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => u4 = u8 ;


SUBSUMPTION: delete
« [ 2655 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = true => u4 = u8 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u2 ; u2, u3 !>


Current goals E30 (1):
[ 2652 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

Current premises H30 (26):
[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;
[ 336 ] le (u2, u3) = false => progAt (Cons (C (u2, u4), Nil), u3) = 0 ;
[ 330 ] le (u2, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = progAt (Cons (C (u6, u7), Nil), u3) ;
[ 378 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) ;
[ 579 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (Cons (C (u5, u8), u9), u3) ;
[ 658 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = progAt (u9, u3) ;
[ 508 ] le (u2, u3) = false /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = u7 ;
[ 511 ] le (u2, u3) = false /\ le (u6, u3) = false => progAt (insAt (Cons (C (u6, u7), Nil), u2, u4), u3) = 0 ;
[ 582 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u7 ;
[ 661 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true => progAt (insAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u2, u4), u3) = u8 ;
[ 740 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = progAt (u9, u3) ;
[ 1258 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 1381 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 743 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = progAt (u9, u3) ;
[ 824 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = u7 ;
[ 1703 ] le (u2, u3) = false /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Nil), u3) = u7 ;
[ 933 ] le (u2, u3) = false /\ le (u6, u3) = false /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Nil)), u3) = 0 ;
[ 1046 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u7 ;
[ 2020 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u7 ;
[ 1157 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u6, u7), Cons (C (u5, u8), u9))), u3) = u8 ;
[ 2188 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u6, u7), Cons (C (u5, u8), u9)), u3) = u8 ;
[ 2284 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = true /\ le (u2, u3) = false /\ le (u6, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;
[ 1160 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false => progAt (insAt (Cons (C (u5, u8), u9), u2, u4), u3) = u8 ;
[ 1587 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = progAt (u9, u3) ;
[ 2519 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = false /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = progAt (u9, u3) ;
[ 2432 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true => progAt (Cons (C (u2, u4), Cons (C (u5, u8), u9)), u3) = u8 ;

TOTAL CASE REWRITING 26: simplify clause
[ 2652 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

at position true/1/[1] on 	progAt (Cons (C (u5, u8), u9), u3)


 The current clause is added to H since the new conjectures are smaller : 

« [ 2652 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false => progAt (Cons (C (u5, u8), u9), u3) = u8 ;

with the rules 

1) [ 137 ] le (time (u1), u2) = true => progAt (Cons (u1, u3), u2) -> er (u1) ;
2) [ 138 ] le (time (u1), u2) = false => progAt (Cons (u1, u3), u2) -> progAt (u3, u2) ;

resulting

» 1) [ 2722 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = u8 ;

using [ 137 ] from R

» 2) [ 2726 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = u8 ;

using [ 138 ] from R



REWRITING 82: simplify by rewriting 
« [ 2722 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = true => er (C (u5, u8)) = u8 ;


- rewriting at the position false/10/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 2729 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = u8 ;


REWRITING 83: simplify by rewriting 
« [ 2726 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (time (C (u5, u8)), u3) = false => progAt (u9, u3) = u8 ;


- rewriting at the position false/10/[1-1]:

time (C (u5, u8))
   is simplified by : time (C (u1, u2)) -> u1   (from [ 105 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u5


» [ 2732 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = false => progAt (u9, u3) = u8 ;


REWRITING 84: simplify by rewriting 
« [ 2729 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => er (C (u5, u8)) = u8 ;


- rewriting at the position true/1/[1]:

er (C (u5, u8))
   is simplified by : er (C (u1, u2)) -> u2   (from [ 106 ] of R)
   with substitution: <! u1, u5 ; u2, u8 !> into
u8


» [ 2735 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => u8 = u8 ;

TAUTOLOGY: delete
« [ 2735 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = true => u8 = u8 ;


SUBSUMPTION: delete
« [ 2732 ] le (u2, u3) = false /\ le (u5, u6) = true /\ sortedT (u9) = true /\ le (timel (u9), u5) = true /\ le (u6, u3) = false /\ le (u5, u3) = true /\ le (u6, u2) = false /\ le (u5, u2) = true /\ le (u2, u3) = false /\ le (u5, u3) = false => progAt (u9, u3) = u8 ;

Subsumed in L by [ 159 ] le (u1, u2) = false /\ le (u1, u2) = true =>  ;

	with epsilon = <! u1, u5 ; u2, u3 !>



The following initial conjectures are inductive consequences of R

[ 276 ] sortedT (u1) = true /\ le (u2, u3) = false => progAt (insAt (u1, u2, u4), u3) = progAt (u1, u3) ;


(* Generating the COQ proof of the conjectures:

  forall u1 u2 u3 u4, (sortedT u1) = true -> (le u2 u3) = false -> (progAt (insAt u1 u2 u4) u3) = (progAt u1 u3)

*)
Elapsed time: 0.358069 s

--- Global statistics of the main successful operations ---

- tautology               : 11 of 685 tries.
- rewriting               : 84 of 466 tries.
- augmentation            : 1 of 222 tries.
- subsumption             : 23 of 214 tries.
- total_case_rewriting    : 26 of 30 tries.
- generate                : 4 of 4 tries.

-----------
  Total clauses: 2757

-----------
  Total lemmas: 4

  Max depth    : 1


All sets of conjectures were successfully processed


